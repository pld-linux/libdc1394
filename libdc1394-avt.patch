diff -Nur libdc1394-2.1.2/dc1394/bayer_avt.c libdc1394_avt-2.1.2/dc1394/bayer_avt.c
--- libdc1394-2.1.2/dc1394/bayer_avt.c	1970-01-01 01:00:00.000000000 +0100
+++ libdc1394_avt-2.1.2/dc1394/bayer_avt.c	2010-01-12 16:30:41.000000000 +0100
@@ -0,0 +1,342 @@
+/*
+ * 1394-Based Digital Camera Control Library
+ *
+ * AVT Bayer pattern decoding functions
+ *
+ * Copyright (C) 2010 Allied Vision Technologies GmbH
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdint.h>
+#include <dc1394/types.h>
+#include <dc1394/log.h>
+#include <string.h>
+
+#ifndef MIN
+  #define MIN(a,b) ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
+  #define MAX(a,b) ((a) < (b) ? (b) : (a))
+#endif
+
+//! Structure for accessing data in the YUV 4:4:4 format (YUV)
+typedef struct
+{
+    uint8_t Y;   //!< Luma
+    uint8_t U;   //!< U
+    uint8_t V;   //!< V
+} S_YUV444;
+
+//! Structure for accessing data in the YUV 4:2:2 format (UYVY)
+typedef struct
+{
+    uint8_t U;   //!< the U part for both pixels
+    uint8_t Y0;  //!< the intensity of the first pixel
+    uint8_t V;   //!< the V part for both pixels
+    uint8_t Y1;  //!< the intensity of the second pixel
+}  S_YUV422;
+
+//! Structure for accessing data in the 24 bit RGB format
+typedef struct
+{
+    uint8_t R;   //!< red
+    uint8_t G;   //!< green
+    uint8_t B;   //!< blue
+}  S_RGB8;
+
+////////////////////////////////////////////////////////////////////////////////
+// Convert raw mode with 8 bit values
+////////////////////////////////////////////////////////////////////////////////
+
+void dc1394_avt_Raw8ToYUV444(uint8_t *pDst1, const uint8_t *pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern)
+{
+    const uint8_t    *pBuf    =   pSrc;
+    const uint8_t    *pR,*pB,*pG0,*pG1; // G0:the green pixel in the same column as the red pixel
+    uint32_t         i,j;
+    S_YUV444 *pDst         = (S_YUV444*) pDst1;
+    uint32_t uColorOffsetY = (uint32_t) bayerPattern/2;
+    uint32_t uColorOffsetX = (uint32_t) bayerPattern%2;
+    int16_t U;
+    int16_t V;
+    uint8_t G;
+
+
+    for(i=uColorOffsetY; i<YSize+uColorOffsetY-1; i++,pBuf+=XSize)
+    {
+        switch((i&1)+2*uColorOffsetX)
+        {
+        case 3:
+            pB  = pBuf; 
+            pG0 = pB+1; 
+            pG1 = pB+XSize; 
+            pR  = pG1+1;
+            break;
+        case 2:
+            pG1 = pBuf; 
+            pR  = pG1+1;
+            pB  = pG1+XSize; 
+            pG0 = pB+1;
+            break;
+        case 1:
+            pG0 = pBuf; 
+            pB  = pG0+1;
+            pR  = pG0+XSize; 
+            pG1 = pR+1;
+            break;
+        case 0:
+        default:
+            pR  = pBuf; 
+            pG1 = pR+1; 
+            pG0 = pR+XSize; 
+            pB  = pG0+1;
+            break;
+        }
+
+        // Go through all pixels
+        for(j=uColorOffsetX;j<XSize+uColorOffsetX-1;j++)
+        {
+            G       = (uint8_t)(((uint16_t)*pG0+*pG1)/2);
+            U       = ((*pB)<<7) - 43* *pR - 85* G;
+            V       = ((*pR)<<7) -107* G - 21* *pB;
+            pDst->Y = (uint8_t)(( 77* *pR +150* G + 29* *pB) >>8);
+            pDst->U = (uint8_t)((U>>8) + 128);
+            pDst->V = (uint8_t)((V>>8) + 128);
+
+            pDst++;
+
+            if(j&1)
+            {
+                pB  +=2; 
+                pG1 +=2;
+            }
+            else
+            {
+                pR  +=2; 
+                pG0 +=2;
+            }
+        }
+        pDst->Y = (pDst-1)->Y;
+        pDst->U = (pDst-1)->U;
+        pDst->V = (pDst-1)->V;
+
+        pDst++;
+    }
+
+    memcpy(pDst,pDst-XSize,XSize*sizeof(S_YUV444));
+}
+
+
+/*
+ * Inplace YUV444->YUV422 conversion with horizontal averaging.
+ * A 4x1 averaging window is used.
+ * Image width is expected to be a multiple of 2.
+ * The resulting data is not packed in YUV 422 format, data format is still YUV444.
+ * However, valid U and V components are stored only for pixels with even X-coordinate.
+ */
+void dc1394_avt_YUV_averaging_4(uint8_t *pDst, uint32_t XSize, uint32_t YSize)
+{
+    S_YUV444 *dst = (S_YUV444*) pDst;
+
+    S_YUV444 *pLineEnd = dst + XSize - 4;
+    S_YUV444 *pFrameEnd = dst + (XSize*YSize) - 2;
+
+    for(;;)
+    {
+        dst[0].U = (uint8_t) ( ( (uint16_t) dst[0].U + dst[1].U + dst[2].U + dst[3].U ) / 4 );
+        dst[0].V = (uint8_t) ( ( (uint16_t) dst[0].V + dst[1].V + dst[2].V + dst[3].V ) / 4 );
+
+        if( dst == pLineEnd )
+        {
+            /* a smaller averaging window is used for the last column */
+            dst += 2;
+            dst[0].U = (uint8_t) ( ( (uint16_t) dst[0].U + dst[1].U ) / 2 );
+            dst[0].V = (uint8_t) ( ( (uint16_t) dst[0].V + dst[1].V ) / 2 );
+            if( dst == pFrameEnd )
+            {
+                break;
+            }
+            pLineEnd += XSize;
+        } 
+        dst += 2;
+    }
+}
+
+
+/*
+ * Inplace YUV444->YUV422 conversion with horizontal averaging.
+ * A 2x1 averaging window is used.
+ * Image width is expected to be a multiple of 2.
+ * The resulting data is not packed in YUV 422 format, data format is still YUV444.
+ * However, valid U and V components are stored only for pixels with even X-coordinate.
+ */
+void dc1394_avt_YUV_averaging_2(void *pDst, uint32_t XSize, uint32_t YSize) 
+
+{
+
+    S_YUV444        *dst    = (S_YUV444*) ( pDst);
+
+    S_YUV444        *pFrameEnd = dst+(XSize*YSize);
+
+    for(;;)
+    {
+        dst[0].U = (uint8_t) ( ( (uint16_t) dst[0].U + dst[1].U ) / 2 );
+        dst[0].V = (uint8_t) ( ( (uint16_t) dst[0].V + dst[1].V ) / 2 );
+        dst += 2;
+        if( dst >= pFrameEnd )
+        {
+            break;
+        }
+    }
+}
+
+
+/*
+ * Inplace YUV444->YUV422 conversion with horizontal averaging.
+ * A 4x2 averaging window is used.
+ * Image width is expected to be a multiple of 2.
+ * The resulting data is not packed in YUV 422 format, data format is still YUV444.
+ * However, valid U and V components are stored only for pixels with even X-coordinate.
+ */
+void dc1394_avt_YUV_averaging_42(uint8_t *pDst, uint32_t XSize, uint32_t YSize)
+{
+    S_YUV444 *pYUV         = (S_YUV444 *) pDst;
+    S_YUV444 *pYUV_NextRow = pYUV + XSize;
+    S_YUV444 *pLineEnd     = pYUV + XSize - 4;
+    S_YUV444 *pFrameEnd    = pYUV + (XSize*(YSize-1));
+
+    /* special treatment for first pixel */
+    pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[0].U + pYUV[1].U + pYUV[2].U + 
+                              pYUV_NextRow[0].U + pYUV_NextRow[1].U + pYUV_NextRow[2].U + 3 ) / 6 ); 
+    pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[0].V + pYUV[1].V + pYUV[2].V + 
+                              pYUV_NextRow[0].V + pYUV_NextRow[1].V + pYUV_NextRow[2].V + 3 ) / 6 ); 
+
+    for (;;)
+    {
+        /* main loop - standard processing */
+        pYUV += 2;
+        pYUV_NextRow += 2;
+        pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[-1].U + pYUV[0].U + pYUV[1].U + pYUV[2].U + 
+                                  pYUV_NextRow[-1].U + pYUV_NextRow[0].U + pYUV_NextRow[1].U + pYUV_NextRow[2].U + 4 ) / 8 );
+        pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[-1].V + pYUV[0].V + pYUV[1].V + pYUV[2].V + 
+                                  pYUV_NextRow[-1].V + pYUV_NextRow[0].V + pYUV_NextRow[1].V + pYUV_NextRow[2].V + 4 ) / 8 );
+
+        if( pYUV == pLineEnd )
+        {
+            /* special treatment for last pixel of each row */
+            pYUV += 2;
+            pYUV_NextRow += 2;
+            pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[-1].U + pYUV[0].U + pYUV[1].U + 
+                                  pYUV_NextRow[-1].U + pYUV_NextRow[0].U + pYUV_NextRow[1].U + 3 ) / 6 ); 
+            pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[-1].V + pYUV[0].V + pYUV[1].V  + 
+                                  pYUV_NextRow[-1].V + pYUV_NextRow[0].V + pYUV_NextRow[1].V + 3 ) / 6 );
+            pLineEnd += XSize;
+
+            pYUV += 2;
+            pYUV_NextRow += 2;
+            if ( pYUV == pFrameEnd )
+            {
+                break;
+            }
+
+            /* special treatment for first pixel of each row */
+            pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[0].U + pYUV[1].U + pYUV[2].U + 
+                              pYUV_NextRow[0].U + pYUV_NextRow[1].U + pYUV_NextRow[2].U + 3 ) / 6 ); 
+            pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[0].V + pYUV[1].V + pYUV[2].V + 
+                              pYUV_NextRow[0].V + pYUV_NextRow[1].V + pYUV_NextRow[2].V + 3 ) / 6 ); 
+        }
+    }
+
+    /* special treatment for last line */
+    pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[0].U + pYUV[1].U + pYUV[2].U + 1 ) / 3 ); 
+    pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[0].V + pYUV[1].V + pYUV[2].V + 1 ) / 3 ); 
+    for (;;)
+    {
+        pYUV += 2;
+        pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[-1].U + pYUV[0].U + pYUV[1].U + pYUV[2].U + 2 ) / 4 ); 
+        pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[-1].V + pYUV[0].V + pYUV[1].V + pYUV[2].V + 2 ) / 4 );
+        if( pYUV == pLineEnd )
+        {
+            /* special treatment for last pixel */
+            pYUV += 2;
+            pYUV[0].U = (uint8_t) ( ( (uint16_t) pYUV[-1].U + pYUV[0].U + pYUV[1].U + 1 ) / 3 ); 
+            pYUV[0].V = (uint8_t) ( ( (uint16_t) pYUV[-1].V + pYUV[0].V + pYUV[1].V + 1 ) / 3 );
+            break;
+        }
+    }
+}
+
+
+
+/*
+ * Inplace YUV422->RGB conversion.
+ * Image width is expected to be a multiple of 2.
+ * The input data is expected to be in "YUV422 unpacked" format as produced by
+ * dc1394_avt_YUV_averaging_2, dc1394_avt_YUV_averaging_4, dc1394_avt_YUV_averaging_42.
+ */
+void dc1394_avt_YUV422UnpackedToRGB(uint8_t *pDst, uint32_t nPixelCount)
+{
+    S_RGB8 *rgb = (S_RGB8*) (pDst);
+    S_RGB8 *pFrameEnd = rgb + nPixelCount - 2;
+    for(;;)
+    {
+        S_YUV444 *yuv = (S_YUV444*) rgb;
+        uint8_t Y0 = yuv[0].Y;
+        uint8_t U  = yuv[0].U;
+        uint8_t V  = yuv[0].V;
+        uint8_t Y1 = yuv[1].Y;
+
+        const int32_t vr      = (int16_t) ( (float) (V-128) * 1.4022 );
+        const int32_t uvg     = (int16_t) ( (float) (V-128) * (-0.7144) ) + 
+                                 (int16_t) ( (float) (U-128) * (-0.3457) );
+        const int32_t ub      = (int16_t) ( (float) (U-128) * 1.7710 );
+
+        rgb[0].R = MAX( MIN( (int32_t) Y0 + vr , 255 ), 0);
+        rgb[0].G = MAX( MIN( (int32_t) Y0 + uvg, 255 ), 0);
+        rgb[0].B = MAX( MIN( (int32_t) Y0 + ub , 255 ), 0);
+        rgb[1].R = MAX( MIN( (int32_t) Y1 + vr , 255 ), 0);
+        rgb[1].G = MAX( MIN( (int32_t) Y1 + uvg, 255 ), 0);
+        rgb[1].B = MAX( MIN( (int32_t) Y1 + ub , 255 ), 0);
+
+        if( rgb == pFrameEnd )
+        {
+            break;
+        }
+        rgb += 2;
+    }
+}
+
+void dc1394_avt_Raw8ToRGB_YUV422(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern)  
+{
+    dc1394_avt_Raw8ToYUV444(pDst, pSrc, XSize, YSize, bayerPattern);
+    dc1394_avt_YUV_averaging_2( pDst, XSize, YSize);
+    dc1394_avt_YUV422UnpackedToRGB(pDst, XSize*YSize );
+}
+
+void dc1394_avt_Raw8ToRGB_LCAA(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern) 
+{
+    dc1394_avt_Raw8ToYUV444(pDst, pSrc, XSize, YSize, bayerPattern);
+    dc1394_avt_YUV_averaging_4(pDst, XSize, YSize );
+    dc1394_avt_YUV422UnpackedToRGB(pDst, XSize*YSize);
+}
+
+void dc1394_avt_Raw8ToRGB_LCAAV(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern) 
+{
+    dc1394_avt_Raw8ToYUV444(pDst, pSrc, XSize, YSize, bayerPattern);
+    dc1394_avt_YUV_averaging_42( pDst, XSize, YSize);
+    dc1394_avt_YUV422UnpackedToRGB(pDst, XSize*YSize);
+}
+
+
--- libdc1394-2.2.7/dc1394/bayer.c.orig	2023-06-05 13:28:36.000000000 +0200
+++ libdc1394-2.2.7/dc1394/bayer.c	2023-06-26 20:41:42.207095485 +0200
@@ -27,6 +27,7 @@
 #include <stdint.h>
 #include <string.h>
 #include "conversions.h"
+#include "vendor/avt.h"
 
 #define CLIP(in, out)\
    in = in < 0 ? 0 : in;\
@@ -38,6 +39,16 @@
    in = in > ((1<<bits)-1) ? ((1<<bits)-1) : in;\
    out=in;
 
+
+/* debayering methods defined in bayer_avt.c */
+extern void dc1394_avt_Raw8ToRGB_YUV422(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern);
+
+extern void dc1394_avt_Raw8ToRGB_LCAA(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern);
+
+extern void dc1394_avt_Raw8ToRGB_LCAAV(uint8_t *restrict pDst, const uint8_t *restrict pSrc, uint32_t XSize, uint32_t YSize, dc1394color_filter_t bayerPattern);
+
+
+
 void
 ClearBorders(uint8_t *rgb, int sx, int sy, int w)
 {
@@ -2535,6 +2546,15 @@ dc1394_bayer_decoding_8bit(const uint8_t
         return dc1394_bayer_VNG(bayer, rgb, sx, sy, tile);
     case DC1394_BAYER_METHOD_AHD:
         return dc1394_bayer_AHD(bayer, rgb, sx, sy, tile);
+    case DC1394_BAYER_METHOD_AVT_YUV422:
+        dc1394_avt_Raw8ToRGB_YUV422( rgb, bayer, sx, sy, tile);
+        return DC1394_SUCCESS;
+    case DC1394_BAYER_METHOD_AVT_LCAA:
+        dc1394_avt_Raw8ToRGB_LCAA( rgb, bayer, sx, sy, tile);
+        return DC1394_SUCCESS;
+    case DC1394_BAYER_METHOD_AVT_LCAAV:
+        dc1394_avt_Raw8ToRGB_LCAAV( rgb, bayer, sx, sy, tile);
+        return DC1394_SUCCESS;
     default:
         return DC1394_INVALID_BAYER_METHOD;
   }
@@ -2544,6 +2564,10 @@ dc1394_bayer_decoding_8bit(const uint8_t
 dc1394error_t
 dc1394_bayer_decoding_16bit(const uint16_t *restrict bayer, uint16_t *restrict rgb, uint32_t sx, uint32_t sy, dc1394color_filter_t tile, dc1394bayer_method_t method, uint32_t bits)
 {
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     switch (method) {
     case DC1394_BAYER_METHOD_NEAREST:
         return dc1394_bayer_NearestNeighbor_uint16(bayer, rgb, sx, sy, tile, bits);
@@ -2561,6 +2585,10 @@ dc1394_bayer_decoding_16bit(const uint16
         return dc1394_bayer_VNG_uint16(bayer, rgb, sx, sy, tile, bits);
     case DC1394_BAYER_METHOD_AHD:
         return dc1394_bayer_AHD_uint16(bayer, rgb, sx, sy, tile, bits);
+    case DC1394_BAYER_METHOD_AVT_YUV422:
+    case DC1394_BAYER_METHOD_AVT_LCAA:
+    case DC1394_BAYER_METHOD_AVT_LCAAV:
+        return DC1394_FUNCTION_NOT_SUPPORTED;
     default:
         return DC1394_INVALID_BAYER_METHOD;
     }
@@ -2602,7 +2630,9 @@ Adapt_buffer_bayer(dc1394video_frame_t *
 
     // bit depth is conserved for 16 bit and set to 8bit for 8bit:
     if ( (in->color_coding==DC1394_COLOR_CODING_RAW16) || 
-	 (in->color_coding==DC1394_COLOR_CODING_MONO16) )
+	 (in->color_coding==DC1394_COLOR_CODING_MONO16)  ||
+     (in->color_coding==DC1394_COLOR_CODING_AVT_RAW12) ||
+     (in->color_coding==DC1394_COLOR_CODING_AVT_MONO12) )
         out->data_depth=in->data_depth;
     else
         out->data_depth=8;
@@ -2686,6 +2716,15 @@ dc1394_debayer_frames(dc1394video_frame_
             return dc1394_bayer_VNG(in->image, out->image, in->size[0], in->size[1], in->color_filter);
         case DC1394_BAYER_METHOD_AHD:
             return dc1394_bayer_AHD(in->image, out->image, in->size[0], in->size[1], in->color_filter);
+        case DC1394_BAYER_METHOD_AVT_YUV422:
+            dc1394_avt_Raw8ToRGB_YUV422(out->image, in->image, in->size[0], in->size[1], in->color_filter);
+            return DC1394_SUCCESS;
+        case DC1394_BAYER_METHOD_AVT_LCAA:
+            dc1394_avt_Raw8ToRGB_LCAA(out->image, in->image, in->size[0], in->size[1], in->color_filter);
+            return DC1394_SUCCESS;
+        case DC1394_BAYER_METHOD_AVT_LCAAV:
+            dc1394_avt_Raw8ToRGB_LCAAV(out->image, in->image, in->size[0], in->size[1], in->color_filter);
+            return DC1394_SUCCESS;
         }
         break;
     case DC1394_COLOR_CODING_MONO16:
@@ -2694,23 +2733,33 @@ dc1394_debayer_frames(dc1394video_frame_
         if(DC1394_SUCCESS != Adapt_buffer_bayer(in,out,method))
             return DC1394_MEMORY_ALLOCATION_FAILURE;
             
+        int bits;
+        if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+            bits = 16;
+        else
+            bits = in->data_depth;
+
         switch (method) {
         case DC1394_BAYER_METHOD_NEAREST:
-            return dc1394_bayer_NearestNeighbor_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_NearestNeighbor_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_SIMPLE:
-            return dc1394_bayer_Simple_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_Simple_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_BILINEAR:
-            return dc1394_bayer_Bilinear_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_Bilinear_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_HQLINEAR:
-            return dc1394_bayer_HQLinear_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_HQLinear_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_DOWNSAMPLE:
-            return dc1394_bayer_Downsample_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_Downsample_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_EDGESENSE:
-            return dc1394_bayer_EdgeSense_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_EdgeSense_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_VNG:
-            return dc1394_bayer_VNG_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_VNG_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
         case DC1394_BAYER_METHOD_AHD:
-            return dc1394_bayer_AHD_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, in->data_depth);
+            return dc1394_bayer_AHD_uint16((uint16_t*)in->image, (uint16_t*)out->image, in->size[0], in->size[1], in->color_filter, bits);
+        case DC1394_BAYER_METHOD_AVT_YUV422:
+        case DC1394_BAYER_METHOD_AVT_LCAA:
+        case DC1394_BAYER_METHOD_AVT_LCAAV:
+            return DC1394_FUNCTION_NOT_SUPPORTED;
         }
         break;
     default:
diff -Nur libdc1394-2.1.2/dc1394/conversions.c libdc1394_avt-2.1.2/dc1394/conversions.c
--- libdc1394-2.1.2/dc1394/conversions.c	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/conversions.c	2010-01-14 18:19:49.000000000 +0100
@@ -23,6 +23,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include "conversions.h"
+#include "vendor/avt.h"
 
 // this should disappear...
 extern void swab();
@@ -217,12 +218,76 @@
 }
 
 dc1394error_t
+dc1394_MONO12_to_YUV422(const uint8_t* restrict src, uint8_t* restrict dest, uint32_t width, uint32_t height, uint32_t byte_order,                                 uint32_t bits)
+{
+    if(width%2!=0)
+    return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    const uint8_t *       packed   = src;
+    const uint8_t * const frameEnd = src + (width*height*3/2);
+          uint8_t *       yuv      = dest;
+
+    switch (byte_order) {
+    case DC1394_BYTE_ORDER_YUYV:
+        if( bits == 12 || bits == 0 ) {
+            while( packed < frameEnd ) {
+                yuv[0] = packed[0];
+                yuv[1] = 128;
+                yuv[2] = packed[2];
+                yuv[3] = 128; 
+                yuv += 4;
+                packed += 3;
+            }
+        }
+        else { 
+            while( packed < frameEnd ) {
+                yuv[0] = ( ( packed[0]<<4 ) + ( packed[1]&0xf ) ) >> (bits-8);
+                yuv[1] = 128;
+                yuv[2] = ( ( packed[2]<<4 ) + ( (packed[1]&0xf0)>>4 ) ) >> (bits-8);
+                yuv[3] = 128;
+                yuv += 4;
+                packed += 3;
+                }
+        }
+        return DC1394_SUCCESS;
+    case DC1394_BYTE_ORDER_UYVY:
+        if( bits == 12 || bits == 0 ) {
+            while( packed < frameEnd ) {
+                yuv[0] = 128;
+                yuv[1] = packed[0];
+                yuv[2] = 128;
+                yuv[3] = packed[2];
+                yuv += 4;
+                packed += 3;
+            }
+        }
+        else { 
+            while( packed < frameEnd ) {
+                yuv[0] = 128;
+                yuv[1] = ( ( packed[0]<<4 ) + ( packed[1]&0xf ) ) >> (bits-8);
+                yuv[2] = 128;
+                yuv[3] = ( ( packed[2]<<4 ) + ( (packed[1]&0xf0)>>4 ) ) >> (bits-8);
+                yuv += 4;
+                packed += 3;
+                }
+        }
+        return DC1394_SUCCESS;
+    default:
+        return DC1394_INVALID_BYTE_ORDER;
+    }
+}
+
+dc1394error_t
 dc1394_MONO16_to_YUV422(uint8_t *restrict src, uint8_t *restrict dest, uint32_t width, uint32_t height, uint32_t byte_order, uint32_t bits)
 {
     register int i = ((width*height) << 1)-1;
     register int j = ((width*height) << 1)-1;
     register int y0, y1;
 
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     switch (byte_order) {
     case DC1394_BYTE_ORDER_YUYV:
         while (i >= 0) {
@@ -261,6 +326,10 @@
     register int j = (width*height)-1;
     register int y;
 
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     while (i >= 0) {
         y = src[i--];
         dest[j--] = (y + (src[i--]<<8))>>(bits-8);
@@ -268,6 +337,7 @@
     return DC1394_SUCCESS;
 }
 
+
 dc1394error_t
 dc1394_RGB8_to_YUV422(uint8_t *restrict src, uint8_t *restrict dest, uint32_t width, uint32_t height, uint32_t byte_order)
 {
@@ -322,6 +392,10 @@
     register int y0, y1, u0, u1, v0, v1 ;
     register int r, g, b, t;
 
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     switch (byte_order) {
     case DC1394_BYTE_ORDER_YUYV:
         while (i >= 0) {
@@ -385,6 +459,10 @@
     register int j = (width*height) + ( (width*height) << 1 ) -1;
     register int t;
 
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     while (i >= 0) {
         t = src[i--];
         t = (t + (src[i--]<<8))>>(bits-8);
@@ -529,6 +607,10 @@
     register int j = (width*height) + ( (width*height) << 1 )-1;
     register int y;
 
+    /* bits=0 indicates MSB-aligned data */
+    if(bits==0)
+        bits = 16;
+
     while (i > 0) {
         y = src[i--];
         y = (y + (src[i--]<<8))>>(bits-8);
@@ -540,6 +622,49 @@
 }
 
 
+dc1394error_t
+dc1394_MONO12_to_RGB8(const uint8_t *restrict src, uint8_t *restrict dest, uint32_t width, uint32_t height, uint32_t bits)
+{
+    if(width%2!=0)
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    const uint8_t *       packed   = src;
+    const uint8_t * const frameEnd = src + (width*height*3/2);
+          uint8_t *       rgb      = dest;
+
+    if( bits == 12 || bits == 0 ) {
+        while( packed < frameEnd ) {
+            const register int y0 = packed[0];
+            const register int y1 = packed[2];
+            rgb[0] = y0;
+            rgb[1] = y0;
+            rgb[2] = y0;
+            rgb[3] = y1;
+            rgb[4] = y1;
+            rgb[5] = y1;
+            rgb += 6;
+            packed += 3;
+        }
+    }
+    else { 
+        while( packed < frameEnd ) {
+            const register int y0 = ( ( packed[0]<<4 ) + ( packed[1]&0xf ) ) >> (bits-8);
+            const register int y1 = ( ( packed[2]<<4 ) + ( (packed[1]&0xf0)>>4 ) ) >> (bits-8);
+            rgb[0] = y0;
+            rgb[1] = y0;
+            rgb[2] = y0;
+            rgb[3] = y1;
+            rgb[4] = y1;
+            rgb[5] = y1;
+            rgb +=6;
+            packed += 3;
+            }
+    }
+    return DC1394_SUCCESS;
+}
+
+
+
 // change a 16bit stereo image (8bit/channel) into two 8bit images on top
 // of each other
 dc1394error_t
@@ -585,6 +710,9 @@
     case DC1394_COLOR_CODING_RGB16:
         return dc1394_RGB16_to_YUV422(src, dest, width, height, byte_order, bits);
         break;
+    case DC1394_COLOR_CODING_AVT_MONO12:
+    case DC1394_COLOR_CODING_AVT_RAW12:
+        return dc1394_MONO12_to_YUV422(src, dest, width, height, byte_order, bits);
     default:
         return DC1394_FUNCTION_NOT_SUPPORTED;
     }
@@ -605,6 +733,9 @@
     case DC1394_COLOR_CODING_MONO8:
         memcpy(dest, src, width*height);
         break;
+    case DC1394_COLOR_CODING_AVT_MONO12:
+        return dc1394_convert_packed12_to_8(src, dest, width, height, bits);
+        break;
     default:
         return DC1394_FUNCTION_NOT_SUPPORTED;
     }
@@ -641,6 +772,10 @@
     case DC1394_COLOR_CODING_RGB8:
       memcpy(dest, src, width*height*3);
       break;
+    case DC1394_COLOR_CODING_AVT_MONO12:
+    case DC1394_COLOR_CODING_AVT_RAW12:
+        return dc1394_MONO12_to_RGB8 (src, dest, width, height, bits);
+        break;
     default:
         return DC1394_FUNCTION_NOT_SUPPORTED;
     }
@@ -648,6 +783,78 @@
     return DC1394_SUCCESS;
 }
 
+
+dc1394error_t
+dc1394_convert_packed12_to_16(const uint8_t *restrict src, uint16_t *restrict dest, uint32_t width, uint32_t height, uint8_t bits)
+{
+    if(width%2!=0)
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    const uint8_t  *       packed   = src;
+    const uint8_t  * const frameEnd = src + (width*height*3/2);
+          uint16_t *       unpacked = dest;
+
+    if( bits == 0 )
+    {
+        /* convert MSB-aligned data to MSB-aligned data */
+        while( packed < frameEnd )
+        {
+            unpacked[0] = ( packed[0]<<8 ) + ( (packed[1]&0xf )<<4 );
+            unpacked[1] = ( packed[2]<<8 ) + (packed[1]&0xf0);
+            unpacked +=2;
+            packed += 3;
+        }
+    }
+    else
+    {
+        /* convert LSB-aligned data to LSB-aligned data */
+        while( packed < frameEnd )
+        {
+            unpacked[0] = ( packed[0]<<4 ) + ( packed[1]&0xf );
+            unpacked[1] = ( packed[2]<<4 ) + ( (packed[1]&0xf0)>>4 );
+            unpacked +=2;
+            packed += 3;
+        }
+    }
+
+    return DC1394_SUCCESS;
+}
+
+
+dc1394error_t
+dc1394_convert_packed12_to_8(const uint8_t *restrict src, uint8_t *restrict dest, uint32_t width, uint32_t height, uint32_t bits)
+{
+    if(width%2!=0)
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    const uint8_t *       packed   = src;
+    const uint8_t * const frameEnd = src + (width*height*3/2);
+          uint8_t *       unpacked = dest;
+
+    if(bits==12 || bits==0)
+    {
+        while( packed < frameEnd )
+        {
+            unpacked[0] = packed[0];
+            unpacked[1] = packed[2];
+            unpacked +=2;
+            packed += 3;
+        }
+    }
+    else
+    {
+        while( packed < frameEnd )
+        {
+            unpacked[0] = ( ( packed[0]<<4 ) + ( packed[1]&0xf ) ) >> (bits-8);
+            unpacked[1] = ( ( packed[2]<<4 ) + ( (packed[1]&0xf0)>>4 ) ) >> (bits-8);
+            unpacked +=2;
+            packed += 3;
+        }
+    }
+    return DC1394_SUCCESS;
+}
+
+
 dc1394error_t
 Adapt_buffer_convert(dc1394video_frame_t *in, dc1394video_frame_t *out)
 {
@@ -773,8 +980,11 @@
 
             if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
                 return DC1394_MEMORY_ALLOCATION_FAILURE;
-                
-            return dc1394_MONO16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, in->data_depth);
+
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, 0);
+            else
+                return dc1394_MONO16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, in->data_depth);
             break;
             
         case DC1394_COLOR_CODING_RGB16:
@@ -782,9 +992,23 @@
             if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
                 return DC1394_MEMORY_ALLOCATION_FAILURE;
                 
-            return dc1394_RGB16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, in->data_depth);
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_RGB16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, 0);
+            else
+                return dc1394_RGB16_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, in->data_depth);
             break;
             
+        case DC1394_COLOR_CODING_AVT_MONO12:
+        case DC1394_COLOR_CODING_AVT_RAW12:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO12_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, 0);
+            else
+                return dc1394_MONO12_to_YUV422(in->image, out->image, in->size[0], in->size[1], out->yuv_byte_order, in->data_depth);
+            break;
         default:
             return DC1394_FUNCTION_NOT_SUPPORTED;
         }
@@ -796,7 +1020,10 @@
             if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
                 return DC1394_MEMORY_ALLOCATION_FAILURE;
                 
-            return dc1394_MONO16_to_MONO8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO16_to_MONO8(in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_MONO16_to_MONO8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
             break;
             
         case DC1394_COLOR_CODING_MONO8:
@@ -807,6 +1034,16 @@
             memcpy(out->image, in->image, in->size[0]*in->size[1]);
             break;
             
+        case DC1394_COLOR_CODING_AVT_MONO12:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_convert_packed12_to_8(in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_convert_packed12_to_8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            break;
+
         default:
             return DC1394_FUNCTION_NOT_SUPPORTED;
         }
@@ -818,7 +1055,10 @@
             if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
                 return DC1394_MEMORY_ALLOCATION_FAILURE;
                 
-            return dc1394_RGB16_to_RGB8 (in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_RGB16_to_RGB8 (in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_RGB16_to_RGB8 (in->image, out->image, in->size[0], in->size[1], in->data_depth);
             break;
             
         case DC1394_COLOR_CODING_YUV444:
@@ -860,7 +1100,10 @@
             if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
                 return DC1394_MEMORY_ALLOCATION_FAILURE;
                 
-            return dc1394_MONO16_to_RGB8 (in->image, out->image, in->size[0], in->size[1],in->data_depth);
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO16_to_RGB8 (in->image, out->image, in->size[0], in->size[1],0);
+            else
+                return dc1394_MONO16_to_RGB8 (in->image, out->image, in->size[0], in->size[1],in->data_depth);
             break;
             
         case DC1394_COLOR_CODING_RGB8:
@@ -871,6 +1114,53 @@
             memcpy(out->image, in->image, in->size[0]*in->size[1]*3);
             break;
             
+        case DC1394_COLOR_CODING_AVT_MONO12:
+        case DC1394_COLOR_CODING_AVT_RAW12:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO12_to_RGB8(in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_MONO12_to_RGB8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            break;
+        default:
+            return DC1394_FUNCTION_NOT_SUPPORTED;
+        }
+        break;
+    case DC1394_COLOR_CODING_RAW8:
+        switch(in->color_coding) {
+        case DC1394_COLOR_CODING_RAW16:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+                
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_MONO16_to_MONO8(in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_MONO16_to_MONO8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            break;
+            
+        case DC1394_COLOR_CODING_RAW8:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+                
+            memcpy(out->image, in->image, in->size[0]*in->size[1]);
+            break;
+            
+        case DC1394_COLOR_CODING_AVT_RAW12:
+
+            if(DC1394_SUCCESS != Adapt_buffer_convert(in,out))
+                return DC1394_MEMORY_ALLOCATION_FAILURE;
+
+            if(in->camera && DC1394_AVT_VENDOR_ID==in->camera->vendor_id)
+                return dc1394_convert_packed12_to_8(in->image, out->image, in->size[0], in->size[1], 0);
+            else
+                return dc1394_convert_packed12_to_8(in->image, out->image, in->size[0], in->size[1], in->data_depth);
+            break;
+
         default:
             return DC1394_FUNCTION_NOT_SUPPORTED;
         }
diff -Nur libdc1394-2.1.2/dc1394/conversions.h libdc1394_avt-2.1.2/dc1394/conversions.h
--- libdc1394-2.1.2/dc1394/conversions.h	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/conversions.h	2010-01-12 15:39:53.000000000 +0100
@@ -49,10 +49,13 @@
     DC1394_BAYER_METHOD_DOWNSAMPLE,
     DC1394_BAYER_METHOD_EDGESENSE,
     DC1394_BAYER_METHOD_VNG,
-    DC1394_BAYER_METHOD_AHD
+    DC1394_BAYER_METHOD_AHD,
+    DC1394_BAYER_METHOD_AVT_YUV422,
+    DC1394_BAYER_METHOD_AVT_LCAA,
+    DC1394_BAYER_METHOD_AVT_LCAAV
 } dc1394bayer_method_t;
 #define DC1394_BAYER_METHOD_MIN      DC1394_BAYER_METHOD_NEAREST
-#define DC1394_BAYER_METHOD_MAX      DC1394_BAYER_METHOD_AHD
+#define DC1394_BAYER_METHOD_MAX      DC1394_BAYER_METHOD_AVT_LCAAV
 #define DC1394_BAYER_METHOD_NUM     (DC1394_BAYER_METHOD_MAX-DC1394_BAYER_METHOD_MIN+1)
 
 /**
@@ -101,7 +104,8 @@
  **********************************************************************/
 
 /**
- * Converts an image buffer to YUV422
+ * Converts an image buffer to YUV422.
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
  */
 dc1394error_t
 dc1394_convert_to_YUV422(uint8_t *src, uint8_t *dest, uint32_t width, uint32_t height, uint32_t byte_order,
@@ -109,6 +113,7 @@
 
 /**
  * Converts an image buffer to MONO8
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
  */
 dc1394error_t
 dc1394_convert_to_MONO8(uint8_t *src, uint8_t *dest, uint32_t width, uint32_t height, uint32_t byte_order,
@@ -116,12 +121,34 @@
 
 /**
  * Converts an image buffer to RGB8
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
  */
 dc1394error_t
 dc1394_convert_to_RGB8(uint8_t *src, uint8_t *dest, uint32_t width, uint32_t height, uint32_t byte_order,
                        dc1394color_coding_t source_coding, uint32_t bits);
 
 /**********************************************************************
+ *  CONVERSION FUNCTIONS FOR AVT 12 BIT PACKED FORMATS
+ **********************************************************************/
+
+/**
+ * Converts 12 bit packed mono and raw to 16 bit mono and raw, respectively.
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
+ */
+dc1394error_t
+dc1394_convert_packed12_to_16(const uint8_t *restrict src, uint16_t *restrict dest, uint32_t width, uint32_t height,
+                                    uint8_t bits);
+
+
+/**
+ * Converts 12 bit packed mono and raw to 8 bit mono and raw, respectively
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
+ */
+dc1394error_t
+dc1394_convert_packed12_to_8(const uint8_t *restrict src, uint8_t *restrict dest, uint32_t width, uint32_t height,
+                                 uint32_t bits);
+
+/**********************************************************************
  *  CONVERSION FUNCTIONS FOR STEREO IMAGES
  **********************************************************************/
 
@@ -158,7 +185,17 @@
  *  - AHD              : Adaptive Homogeneity-Directed Demosaicing Algorithm, by K. Hirakawa    *
  *                       and T.W. Parks, IEEE Transactions on Image Processing, Vol. 14, Nr. 3, *
  *                       March 2005, pp. 360 - 369.                                             *
- *                                                                                              *
+ *  - AVT YUV422       : Conversion via interpolated YUV422 format                              *
+ *                       This algorithm is used by AVT Marlin cameras internally.               *
+ *                       Only 8-bit conversions are supported yet.                              *
+ *  - AVT LCAA         : Conversion via interpolated YUV422 format with extra color             *
+ *                       antialiasing (horizontal)                                              *
+ *                       This algorithm is used by AVT Stingray cameras internally.             *
+ *                       Only 8-bit conversions are supported yet.                              *
+ *  - AVT LCAAV        : Conversion via interpolated YUV422 format with extra color             *
+ *                       antialiasing (horizontal and vertical)                                 *
+ *                       This algorithm is used by AVT Pike cameras internally.                 *
+ *                       Only 8-bit conversions are supported yet.                              *
  ************************************************************************************************/
 
 /**
@@ -171,6 +208,7 @@
 
 /**
  * Perform de-mosaicing on an 16-bit image buffer
+ * For images with MSB-aligned data (as produced by AVT cameras), 'bits' should be set to 0.
  */
 dc1394error_t
 dc1394_bayer_decoding_16bit(const uint16_t *bayer, uint16_t *rgb,
--- libdc1394-2.2.7/dc1394/format7.c.orig	2020-04-04 07:28:12.000000000 +0200
+++ libdc1394-2.2.7/dc1394/format7.c	2023-06-26 20:48:20.658270224 +0200
@@ -34,6 +34,7 @@
 #include "utils.h"
 #include "config.h"
 #include "log.h"
+#include "vendor/avt.h"
 
 #ifdef __MINGW32__
 #include <unistd.h>
@@ -193,7 +194,18 @@ _dc1394_format7_set_color_coding(dc1394c
     if (!dc1394_is_video_mode_scalable(video_mode))
         return DC1394_INVALID_VIDEO_MODE;
 
-    color_coding-= DC1394_COLOR_CODING_MIN;
+    switch(color_coding)
+    {
+        case DC1394_COLOR_CODING_AVT_MONO12:
+            color_coding = DC1394_AVT_MONO12_CC_ID;
+            break;
+        case DC1394_COLOR_CODING_AVT_RAW12:
+            color_coding = DC1394_AVT_RAW12_CC_ID;
+            break;
+        default:
+            color_coding-= DC1394_COLOR_CODING_MIN;
+            break;
+    }
     color_coding=color_coding<<24;
     err=dc1394_set_format7_register(camera, video_mode,REG_CAMERA_FORMAT7_COLOR_CODING_ID, (uint32_t)color_coding);
     DC1394_ERR_RTN(err, "Format7 color coding setting failure");
@@ -333,7 +345,18 @@ dc1394_format7_get_color_coding(dc1394ca
     DC1394_ERR_RTN(err, "Could not get current color_id");
 
     value=value>>24;
-    *color_coding= (uint32_t)value+DC1394_COLOR_CODING_MIN;
+    switch(value)
+    {
+        case DC1394_AVT_MONO12_CC_ID:
+            *color_coding = DC1394_COLOR_CODING_AVT_MONO12;
+            break;
+        case DC1394_AVT_RAW12_CC_ID:
+            *color_coding = DC1394_COLOR_CODING_AVT_RAW12;
+            break;
+        default:
+            *color_coding= (uint32_t)value+DC1394_COLOR_CODING_MIN;
+            break;
+    }
 
     return err;
 }
@@ -361,6 +384,21 @@ dc1394_format7_get_color_codings(dc1394c
         }
     }
 
+    /* check vendor-specific AVT 12 bit modes */
+    if (camera->vendor_id==DC1394_AVT_VENDOR_ID) {
+        dc1394error_t err2=dc1394_get_format7_register(camera, video_mode, REG_CAMERA_FORMAT7_COLOR_CODING_INQ+16, &value);
+        if (DC1394_SUCCESS==err2) {
+            if (( value & (0x1 << (31-DC1394_AVT_MONO12_CC_ID+128))) > 0) {
+                color_codings->codings[color_codings->num]=DC1394_COLOR_CODING_AVT_MONO12;
+                color_codings->num++;
+            }
+            if (( value & (0x1 << (31-DC1394_AVT_RAW12_CC_ID+128))) > 0) {
+                color_codings->codings[color_codings->num]=DC1394_COLOR_CODING_AVT_RAW12;
+                color_codings->num++;
+            }
+        }
+    }
+
     return err;
 }
 
@@ -665,7 +703,8 @@ dc1394_format7_get_color_filter(dc1394ca
     if (!dc1394_is_video_mode_scalable(video_mode))
         return DC1394_INVALID_VIDEO_MODE;
 
-    if (camera->iidc_version<DC1394_IIDC_VERSION_1_31)
+    /* some AVT IIDC 1.30 cameras support the COLOR_FILTER_ID register */
+    if (camera->iidc_version<DC1394_IIDC_VERSION_1_31 && camera->vendor_id!=DC1394_AVT_VENDOR_ID)
         return DC1394_FUNCTION_NOT_SUPPORTED;
 
     err=dc1394_get_format7_register(camera, video_mode, REG_CAMERA_FORMAT7_COLOR_FILTER_ID, &value);
diff -Nur libdc1394-2.1.2/dc1394/Makefile.am libdc1394_avt-2.1.2/dc1394/Makefile.am
--- libdc1394-2.1.2/dc1394/Makefile.am	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/Makefile.am	2010-01-14 18:56:52.000000000 +0100
@@ -23,6 +23,7 @@
 	internal.h      \
 	conversions.c   \
 	conversions.h   \
+	bayer_avt.c \
 	bayer.c         \
 	log.c		\
 	log.h		\
diff -Nur libdc1394-2.1.2/dc1394/types.h libdc1394_avt-2.1.2/dc1394/types.h
--- libdc1394-2.1.2/dc1394/types.h	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/types.h	2009-10-23 14:00:13.000000000 +0200
@@ -91,12 +91,16 @@
     DC1394_COLOR_CODING_MONO16S,
     DC1394_COLOR_CODING_RGB16S,
     DC1394_COLOR_CODING_RAW8,
-    DC1394_COLOR_CODING_RAW16
+    DC1394_COLOR_CODING_RAW16,
+    DC1394_COLOR_CODING_AVT_MONO12,
+    DC1394_COLOR_CODING_AVT_RAW12
 } dc1394color_coding_t;
 #define DC1394_COLOR_CODING_MIN     DC1394_COLOR_CODING_MONO8
-#define DC1394_COLOR_CODING_MAX     DC1394_COLOR_CODING_RAW16
+#define DC1394_COLOR_CODING_MAX     DC1394_COLOR_CODING_AVT_RAW12
 #define DC1394_COLOR_CODING_NUM    (DC1394_COLOR_CODING_MAX - DC1394_COLOR_CODING_MIN + 1)
 
+#define DC1394_AVT_MONO12_CC_ID 132
+#define DC1394_AVT_RAW12_CC_ID 136
 /**
  * RAW sensor filters. These elementary tiles tesselate the image plane in RAW modes. RGGB should be interpreted in 2D as
  *
diff -Nur libdc1394-2.1.2/dc1394/utils.c libdc1394_avt-2.1.2/dc1394/utils.c
--- libdc1394-2.1.2/dc1394/utils.c	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/utils.c	2009-10-26 14:55:08.000000000 +0100
@@ -201,6 +201,8 @@
     case DC1394_COLOR_CODING_MONO16S:
     case DC1394_COLOR_CODING_RAW8:
     case DC1394_COLOR_CODING_RAW16:
+    case DC1394_COLOR_CODING_AVT_MONO12:
+    case DC1394_COLOR_CODING_AVT_RAW12:
         *is_color=DC1394_FALSE;
         return DC1394_SUCCESS;
     case DC1394_COLOR_CODING_YUV411:
@@ -235,6 +237,10 @@
         // shoudn't we return the real bit depth (e.g. 12) instead of systematically 16?
         *bits = 16;
         return DC1394_SUCCESS;
+    case DC1394_COLOR_CODING_AVT_MONO12:
+    case DC1394_COLOR_CODING_AVT_RAW12:
+        *bits = 12;
+        return DC1394_SUCCESS;
     }
     return DC1394_INVALID_COLOR_CODING;
 }
@@ -248,6 +254,8 @@
         *bits=8;
         return DC1394_SUCCESS;
     case DC1394_COLOR_CODING_YUV411:
+    case DC1394_COLOR_CODING_AVT_MONO12:
+    case DC1394_COLOR_CODING_AVT_RAW12:
         *bits=12;
         return DC1394_SUCCESS;
     case DC1394_COLOR_CODING_MONO16:
diff -Nur libdc1394-2.1.2/dc1394/vendor/avt.c libdc1394_avt-2.1.2/dc1394/vendor/avt.c
--- libdc1394-2.1.2/dc1394/vendor/avt.c	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/vendor/avt.c	2010-04-30 13:37:23.000000000 +0200
@@ -7,6 +7,8 @@
  *
  * Copyright (C) 2005 Inria Sophia-Antipolis
  *
+ * Additions by Allied Vision Technologies GmbH.
+ *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
@@ -27,74 +29,128 @@
 #include <string.h>
 #include "vendor/avt.h"
 
+#include "avt_csr_structs_adv.h"
+
+#ifndef MIN
+  #define MIN(a,b) ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
+  #define MAX(a,b) ((a) < (b) ? (b) : (a))
+#endif
+
 /********************************************************/
 /* Configuration Register Offsets for Advances features */
 /********************************************************/
 
-#define REG_CAMERA_AVT_VERSION_INFO1                        0x010U
-#define REG_CAMERA_AVT_VERSION_INFO3                        0x018U
+#define REG_CAMERA_AVT_VERSION_INFO1                    0x010U
+#define REG_CAMERA_AVT_VERSION_INFO3                    0x018U
 #define REG_CAMERA_AVT_ADV_INQ_1                        0x040U
 #define REG_CAMERA_AVT_ADV_INQ_2                        0x044U
 #define REG_CAMERA_AVT_ADV_INQ_3                        0x048U
 #define REG_CAMERA_AVT_ADV_INQ_4                        0x04CU
-#define REG_CAMERA_AVT_MAX_RESOLUTION                        0x200U
-#define REG_CAMERA_AVT_TIMEBASE                                0x208U
-#define REG_CAMERA_AVT_EXTD_SHUTTER                        0x20CU
-#define REG_CAMERA_AVT_TEST_IMAGE                        0x210U
-#define REG_CAMERA_AVT_SEQUENCE_CTRL                        0x220U
-#define REG_CAMERA_AVT_SEQUENCE_PARAM                        0x224U
-#define REG_CAMERA_AVT_LUT_CTRL                                0x240U
-#define REG_CAMERA_AVT_LUT_MEM_CTRL                        0x244U
-#define REG_CAMERA_AVT_LUT_INFO                                0x248U
+#define REG_CAMERA_AVT_MAX_RESOLUTION                   0x200U
+#define REG_CAMERA_AVT_TIMEBASE                         0x208U
+#define REG_CAMERA_AVT_EXTD_SHUTTER                     0x20CU
+#define REG_CAMERA_AVT_TEST_IMAGE                       0x210U
+#define REG_CAMERA_AVT_SEQUENCE_CTRL                    0x220U
+#define REG_CAMERA_AVT_SEQUENCE_PARAM                   0x224U
+#define REG_CAMERA_AVT_LUT_CTRL                         0x240U
+#define REG_CAMERA_AVT_LUT_MEM_CTRL                     0x244U
+#define REG_CAMERA_AVT_LUT_INFO                         0x248U
 #define REG_CAMERA_AVT_SHDG_CTRL                        0x250U
-#define REG_CAMERA_AVT_SHDG_MEM_CTRL                        0x254U
+#define REG_CAMERA_AVT_SHDG_MEM_CTRL                    0x254U
 #define REG_CAMERA_AVT_SHDG_INFO                        0x258U
-#define REG_CAMERA_AVT_DEFERRED_TRANS                        0x260U
+#define REG_CAMERA_AVT_DEFERRED_TRANS                   0x260U
 #define REG_CAMERA_AVT_FRAMEINFO                        0x270U
-#define REG_CAMERA_AVT_FRAMECOUNTER                        0x274U
-#define REG_CAMERA_AVT_HDR_CONTROL                        0x280U
-#define REG_CAMERA_AVT_KNEEPOINT_1                        0x284U
-#define REG_CAMERA_AVT_KNEEPOINT_2                        0x288U
-#define REG_CAMERA_AVT_KNEEPOINT_3                        0x28CU
-#define REG_CAMERA_AVT_DSNU_CONTROL                        0x290U
-#define REG_CAMERA_AVT_BLEMISH_CONTROL                        0x294U
-#define REG_CAMERA_AVT_IO_INP_CTRL1                        0x300U
-#define REG_CAMERA_AVT_IO_INP_CTRL2                        0x304U
-#define REG_CAMERA_AVT_IO_INP_CTRL3                        0x308U
-#define REG_CAMERA_AVT_IO_INP_CTRL4                        0x30CU
-#define REG_CAMERA_AVT_IO_OUTP_CTRL1                        0x320U
-#define REG_CAMERA_AVT_IO_OUTP_CTRL2                        0x324U
-#define REG_CAMERA_AVT_IO_OUTP_CTRL3                        0x328U
-#define REG_CAMERA_AVT_IO_OUTP_CTRL4                        0x32CU
-#define REG_CAMERA_AVT_IO_INTENA_DELAY                        0x340U
-#define REG_CAMERA_AVT_AUTOSHUTTER_CTRL                        0x360U
-#define REG_CAMERA_AVT_AUTOSHUTTER_LO                        0x364U
-#define REG_CAMERA_AVT_AUTOSHUTTER_HI                        0x368U
-#define REG_CAMERA_AVT_AUTOGAIN_CTRL                        0x370U
-#define REG_CAMERA_AVT_AUTOFNC_AOI                        0x390U
-#define REG_CAMERA_AVT_AF_AREA_POSITION                        0x394U
-#define REG_CAMERA_AVT_AF_AREA_SIZE                        0x398U
-#define REG_CAMERA_AVT_COLOR_CORR                        0x3A0U
-#define REG_CAMERA_AVT_COLOR_CORR_CRR                        0x3A4U
-#define REG_CAMERA_AVT_COLOR_CORR_CGR                        0x3A8U
-#define REG_CAMERA_AVT_COLOR_CORR_CBR                        0x3ACU
-#define REG_CAMERA_AVT_COLOR_CORR_CRG                        0x3B0U
-#define REG_CAMERA_AVT_COLOR_CORR_CGG                        0x3B4U
-#define REG_CAMERA_AVT_COLOR_CORR_CBG                        0x3B8U
-#define REG_CAMERA_AVT_COLOR_CORR_CRB                        0x3BCU
-#define REG_CAMERA_AVT_COLOR_CORR_CGB                        0x3C0U
-#define REG_CAMERA_AVT_COLOR_CORR_CBB                        0x3C4U
-#define REG_CAMERA_AVT_TRIGGER_DELAY                        0x400U
-#define REG_CAMERA_AVT_MIRROR_IMAGE                        0x410U
+#define REG_CAMERA_AVT_FRAMECOUNTER                     0x274U
+#define REG_CAMERA_AVT_HDR_CONTROL                      0x280U
+#define REG_CAMERA_AVT_KNEEPOINT_1                      0x284U
+#define REG_CAMERA_AVT_KNEEPOINT_2                      0x288U
+#define REG_CAMERA_AVT_KNEEPOINT_3                      0x28CU
+#define REG_CAMERA_AVT_DSNU_CONTROL                     0x290U
+#define REG_CAMERA_AVT_BLEMISH_CONTROL                  0x294U
+#define REG_CAMERA_AVT_DPC_CONTROL                      0x298U
+#define REG_CAMERA_AVT_HDR_PIKE_CONTROL                 0x2B0U
+#define REG_CAMERA_AVT_IO_INP_CTRL1                     0x300U
+#define REG_CAMERA_AVT_IO_INP_CTRL2                     0x304U
+#define REG_CAMERA_AVT_IO_INP_CTRL3                     0x308U
+#define REG_CAMERA_AVT_IO_INP_CTRL4                     0x30CU
+#define REG_CAMERA_AVT_IO_INP_CTRL5                     0x310U
+#define REG_CAMERA_AVT_IO_INP_CTRL6                     0x314U
+#define REG_CAMERA_AVT_IO_INP_CTRL7                     0x318U
+#define REG_CAMERA_AVT_IO_INP_CTRL8                     0x31CU
+#define REG_CAMERA_AVT_IO_OUTP_CTRL1                    0x320U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL2                    0x324U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL3                    0x328U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL4                    0x32CU
+#define REG_CAMERA_AVT_IO_OUTP_CTRL5                    0x330U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL6                    0x334U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL7                    0x338U
+#define REG_CAMERA_AVT_IO_OUTP_CTRL8                    0x33CU
+#define REG_CAMERA_AVT_IO_INTENA_DELAY                  0x340U
+#define REG_CAMERA_AVT_AUTOSHUTTER_CTRL                 0x360U
+#define REG_CAMERA_AVT_AUTOSHUTTER_LO                   0x364U
+#define REG_CAMERA_AVT_AUTOSHUTTER_HI                   0x368U
+#define REG_CAMERA_AVT_AUTOGAIN_CTRL                    0x370U
+#define REG_CAMERA_AVT_AUTOFNC_AOI                      0x390U
+#define REG_CAMERA_AVT_AF_AREA_POSITION                 0x394U
+#define REG_CAMERA_AVT_AF_AREA_SIZE                     0x398U
+#define REG_CAMERA_AVT_COLOR_CORR                       0x3A0U
+#define REG_CAMERA_AVT_COLOR_CORR_CRR                   0x3A4U
+#define REG_CAMERA_AVT_COLOR_CORR_CGR                   0x3A8U
+#define REG_CAMERA_AVT_COLOR_CORR_CBR                   0x3ACU
+#define REG_CAMERA_AVT_COLOR_CORR_CRG                   0x3B0U
+#define REG_CAMERA_AVT_COLOR_CORR_CGG                   0x3B4U
+#define REG_CAMERA_AVT_COLOR_CORR_CBG                   0x3B8U
+#define REG_CAMERA_AVT_COLOR_CORR_CRB                   0x3BCU
+#define REG_CAMERA_AVT_COLOR_CORR_CGB                   0x3C0U
+#define REG_CAMERA_AVT_COLOR_CORR_CBB                   0x3C4U
+#define REG_CAMERA_AVT_TRIGGER_DELAY                    0x400U
+#define REG_CAMERA_AVT_MIRROR_IMAGE                     0x410U
 #define REG_CAMERA_AVT_CHANNEL_ADJUST_CTRL              0x420U
-#define REG_CAMERA_AVT_CHANNEL_ADJUST_VALUE                0x424U
-#define REG_CAMERA_AVT_SOFT_RESET                        0x510U
-#define REG_CAMERA_AVT_HSNRR                                 0x520U
-#define REG_CAMERA_AVT_GPDATA_INFO                        0xFFCU
-#define REG_CAMERA_AVT_GPDATA_BUFFER                        0x1000U
+#define REG_CAMERA_AVT_CHANNEL_ADJUST_VALUE             0x424U
+#define REG_CAMERA_AVT_CHANNEL_ADJUST_OFFSET_CTRL       0x430U
+#define REG_CAMERA_AVT_CHANNEL_ADJUST_OFFSET_VALUE      0x434U
+#define REG_CAMERA_AVT_LOW_SMEAR                        0x440U
+#define REG_CAMERA_AVT_SOFT_RESET                       0x510U
+#define REG_CAMERA_AVT_HSNRR                            0x520U
+#define REG_CAMERA_AVT_TIMESTAMP                        0x540U
+#define REG_CAMERA_AVT_USER_PROFILE                     0x550U
+#define REG_CAMERA_AVT_MAX_ISO_SIZE                     0x560U
+#define REG_CAMERA_AVT_PARAMUPD_MODE                    0x570U
+#define REG_CAMERA_AVT_LOW_NOISE_BINNING                0x5B0U
+#define REG_CAMERA_AVT_GLOBAL_RESET_RELEASE_SHUTTER     0x5C0U
+#define REG_CAMERA_AVT_TIMESTAMP_NEW                    0x600U
+#define REG_CAMERA_AVT_FRAMEINFO_NEW                    0x610U
+#define REG_CAMERA_AVT_TRGCOUNTER_NEW                   0x620U
+#define REG_CAMERA_AVT_SIS                              0x630U
+#define REG_CAMERA_AVT_SWFEATURE                        0x640U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL1                0x800U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL2                0x804U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL3                0x808U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL4                0x80CU
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL5                0x810U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL6                0x814U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL7                0x818U
+#define REG_CAMERA_AVT_IO_OUTP_PWM_CTRL8                0x81CU
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL1            0x840U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL2            0x850U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL3            0x860U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL4            0x870U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL5            0x880U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL6            0x890U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL7            0x8A0U
+#define REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL8            0x8B0U
+
+#define REG_CAMERA_AVT_GPDATA_INFO                      0xFFCU
+#define REG_CAMERA_AVT_GPDATA_BUFFER                    0x1000U
+
+
+#define SIZE_AVT_SMART_FEATURE_STRUCT_V1    584
+
 
 /************************************************************************/
-/* Get Version          (Read Only)                                        */
+/* Get Version          (Read Only)                                     */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_version(dc1394camera_t *camera,
@@ -124,8 +180,87 @@
 
 }
 
+
+/************************************************************************/
+/* Adjust Frames                                                        */
+/************************************************************************/
+dc1394error_t 
+dc1394_avt_adjust_frames(uint32_t Camera_ID, dc1394video_frame_t *frame)
+{
+    /* do nothing when frame is captured by a non-AVT camera */
+	if( NULL!=frame->camera && frame->camera->vendor_id!=DC1394_AVT_VENDOR_ID )
+		return DC1394_SUCCESS;
+
+	switch( frame->color_coding )
+    	{
+        case DC1394_COLOR_CODING_MONO8:
+        case DC1394_COLOR_CODING_MONO16:
+		break;
+	default:
+		return DC1394_SUCCESS;
+	}
+	
+    switch( Camera_ID )
+    {
+        case DC1394_AVT_CAMERA_ID_DF145C:
+        case DC1394_AVT_CAMERA_ID_DF201C:
+        case DC1394_AVT_CAMERA_ID_DF145C_1:
+        case DC1394_AVT_CAMERA_ID_DF201C_1:
+        case DC1394_AVT_CAMERA_ID_MF033C:
+        case DC1394_AVT_CAMERA_ID_MF046C:
+        case DC1394_AVT_CAMERA_ID_MF080C:
+        case DC1394_AVT_CAMERA_ID_MF145C:
+        case DC1394_AVT_CAMERA_ID_MF145C3:
+        case DC1394_AVT_CAMERA_ID_M2F033C:
+        case DC1394_AVT_CAMERA_ID_M2F046C:
+        case DC1394_AVT_CAMERA_ID_M2F080C:
+        case DC1394_AVT_CAMERA_ID_M2F145C:
+        case DC1394_AVT_CAMERA_ID_M2F145C3:
+        case DC1394_AVT_CAMERA_ID_M2F080C_30FPS:
+        case DC1394_AVT_CAMERA_ID_M2F145C4:
+        case DC1394_AVT_CAMERA_ID_M2F201C:
+        case DC1394_AVT_CAMERA_ID_M2F146C:
+        case DC1394_AVT_CAMERA_ID_GF033C:
+        case DC1394_AVT_CAMERA_ID_GF046C:
+        case DC1394_AVT_CAMERA_ID_GF080C:
+        case DC1394_AVT_CAMERA_ID_GF033C_BL:
+        case DC1394_AVT_CAMERA_ID_GF025C:
+        case DC1394_AVT_CAMERA_ID_GF029C:
+        case DC1394_AVT_CAMERA_ID_GF038C:
+        case DC1394_AVT_CAMERA_ID_GF038C_NIR:
+        case DC1394_AVT_CAMERA_ID_GF044C_NIR:
+        case DC1394_AVT_CAMERA_ID_GF080C_BL:
+        case DC1394_AVT_CAMERA_ID_GF044C:
+        case DC1394_AVT_CAMERA_ID_GF146C:
+        case DC1394_AVT_CAMERA_ID_GF503C:
+            frame->color_filter = DC1394_COLOR_FILTER_RGGB;
+            break;
+        case DC1394_AVT_CAMERA_ID_MF131C:
+            frame->color_filter = DC1394_COLOR_FILTER_GBRG;
+            break;
+        case DC1394_AVT_CAMERA_ID_GF036C:
+            frame->color_filter = DC1394_COLOR_FILTER_GRBG;
+            break;
+
+        default:
+            return DC1394_SUCCESS;
+    }
+
+    if( DC1394_COLOR_CODING_MONO8 == frame->color_coding )
+    {
+        frame->color_coding = DC1394_COLOR_CODING_RAW8;
+    }
+    if( DC1394_COLOR_CODING_MONO16 == frame->color_coding )
+    {
+        frame->color_coding = DC1394_COLOR_CODING_RAW16;
+    }
+
+    return DC1394_SUCCESS;
+}
+
+
 /************************************************************************/
-/* Get Advanced feature inquiry                                                */
+/* Get Advanced feature inquiry  - deprecated                           */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_advanced_feature_inquiry(dc1394camera_t *camera,
@@ -139,32 +274,33 @@
     DC1394_ERR_RTN(err,"Could not get AVT advanced features INQ 1");
 
     adv_feature->MaxResolution=                (value & 0x80000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->TimeBase=                        (value & 0x40000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->ExtdShutter=                        (value & 0x20000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->TestImage=                        (value & 0x10000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->FrameInfo=                        (value & 0x08000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->Sequences=                        (value & 0x04000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->VersionInfo=                        (value & 0x02000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->TimeBase=                     (value & 0x40000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->ExtdShutter=                  (value & 0x20000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->TestImage=                    (value & 0x10000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->FrameInfo=                    (value & 0x08000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->Sequences=                    (value & 0x04000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->VersionInfo=                  (value & 0x02000000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_1 7
     adv_feature->Lookup_Tables=                (value & 0x00800000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->Shading=                                (value & 0x00400000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->Shading=                      (value & 0x00400000UL) ? DC1394_TRUE : DC1394_FALSE;
     adv_feature->DeferredTrans=                (value & 0x00200000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->HDR_Mode=                        (value & 0x00100000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->DSNU=                                (value & 0x00080000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->BlemishCorrection=        (value & 0x00040000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->TriggerDelay=                (value & 0x00020000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->MirrorImage=                        (value & 0x00010000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->SoftReset=                        (value & 0x00008000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->HSNR=                                (value & 0x00004000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->ColorCorrection=                (value & 0x00002000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->UserProfiles=                (value & 0x00001000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->HDR_Mode=                     (value & 0x00100000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->DSNU=                         (value & 0x00080000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->BlemishCorrection=            (value & 0x00040000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->TriggerDelay=                 (value & 0x00020000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->MirrorImage=                  (value & 0x00010000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->SoftReset=                    (value & 0x00008000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->HSNR=                         (value & 0x00004000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->ColorCorrection=              (value & 0x00002000UL) ? DC1394_TRUE : DC1394_FALSE;
+
+    adv_feature->UserProfiles=                 (value & 0x00001000UL) ? DC1394_TRUE : DC1394_FALSE; /* whats this? */
     //ADV_INQ_1 20
-    adv_feature->UserSets=                        (value & 0x00000800UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->TimeStamp=                        (value & 0x00000400UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->FrmCntStamp=                        (value & 0x00000200UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->TrgCntStamp=                        (value & 0x00000100UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->UserSets=                     (value & 0x00000400UL) ? DC1394_TRUE : DC1394_FALSE; /* 'user profiles' */
+    adv_feature->TimeStamp=                    (value & 0x00000200UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->FrmCntStamp=                  (value & 0x00000100UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->TrgCntStamp=                  (value & 0x00000080UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_1 25-30
-    adv_feature->GP_Buffer=                        (value & 0x00000001UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->GP_Buffer=                    (value & 0x00000001UL) ? DC1394_TRUE : DC1394_FALSE;
 
     /* Remember this request have been done */
     adv_feature->features_requested = DC1394_TRUE;
@@ -181,36 +317,193 @@
     adv_feature->Output_3=                        (value & 0x00200000UL) ? DC1394_TRUE : DC1394_FALSE;
     adv_feature->Output_4=                        (value & 0x00100000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_2 12-15
-    adv_feature->IntEnaDelay=                        (value & 0x00008000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->IncDecoder=                        (value & 0x00004000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->IntEnaDelay=                     (value & 0x00008000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->IncDecoder=                      (value & 0x00004000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_2 18-31
 
     err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_ADV_INQ_3, &value);
     DC1394_ERR_RTN(err,"Could not get AVT advanced features INQ 3");
 
-    adv_feature->CameraStatus=                (value & 0x80000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->CameraStatus=                    (value & 0x80000000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_3 1-3
-    adv_feature->AutoShutter=                        (value & 0x08000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->AutoShutter=                     (value & 0x08000000UL) ? DC1394_TRUE : DC1394_FALSE;
     adv_feature->AutoGain=                        (value & 0x04000000UL) ? DC1394_TRUE : DC1394_FALSE;
-    adv_feature->AutoFunctionAOI=                (value & 0x02000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->AutoFunctionAOI=                 (value & 0x02000000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_3 7-31
 
     err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_ADV_INQ_4, &value);
     DC1394_ERR_RTN(err,"Could not get AVT advanced features INQ 4");
 
-    adv_feature->HDRPike=                (value & 0x80000000UL) ? DC1394_TRUE : DC1394_FALSE;
+    adv_feature->HDRPike=                         (value & 0x80000000UL) ? DC1394_TRUE : DC1394_FALSE;
     //ADV_INQ_4 1-31
 
     return DC1394_SUCCESS;
 }
 
+
+/************************************************************************/
+/* Get Advanced ('smart') feature inquiry                               */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_smart_feature_inquiry(dc1394camera_t *camera,
+                                                   dc1394_avt_smart_feature_info_t *smart_feature,
+                                                   int size )
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) smart_feature;
+
+    memset ( smart_feature_full, 0, size );
+    smart_feature_full->Size = size;
+
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_ADV_INQ_1, 
+                                             (uint32_t*) &smart_feature_full->Internal.Inq1,
+                                             4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced features INQ");
+
+    smart_feature_full->MaxResolution      = (smart_feature_full->Internal.Inq1.m_bMaxResolution != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->TimeBase           = (smart_feature_full->Internal.Inq1.m_bTimeBase != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ExtdShutter        = (smart_feature_full->Internal.Inq1.m_bExtdShutter != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->TestImage          = (smart_feature_full->Internal.Inq1.m_bTestImage != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->FrameCounter       = (smart_feature_full->Internal.Inq1.m_bFrmCounter2 != 0 || 
+                                              smart_feature_full->Internal.Inq1.m_bFrameInfo != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Sequences          = (smart_feature_full->Internal.Inq1.m_bSequences != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->VersionInfo        = (smart_feature_full->Internal.Inq1.m_bVersionInfo != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Lookup_Tables      = (smart_feature_full->Internal.Inq1.m_bLut != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Shading            = (smart_feature_full->Internal.Inq1.m_bShading != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->DeferredTransport  = (smart_feature_full->Internal.Inq1.m_bDeferredTrans != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->HDR_Mode           = (smart_feature_full->Internal.Inq1.m_bCmosHdrMode != 0 ||
+                                              smart_feature_full->Internal.Inq4.m_bPikeHdrMode != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->DSNU               = (smart_feature_full->Internal.Inq1.m_bFpnCorrection != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->BlemishCorrection  = (smart_feature_full->Internal.Inq1.m_bBlemishCorr != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->TriggerDelay       = (smart_feature_full->Internal.Inq1.m_bTriggerDelay != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->MirrorImage        = (smart_feature_full->Internal.Inq1.m_bImageMirror != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->SoftReset          = (smart_feature_full->Internal.Inq1.m_bSoftReset != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->HSNR               = (smart_feature_full->Internal.Inq1.m_bHighSNR != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ColorCorrection    = (smart_feature_full->Internal.Inq1.m_bColorCorr != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ColorAvg           = (smart_feature_full->Internal.Inq1.m_bColorAvg != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->SIS                = ( /*smart_feature_full->Internal.Inq1.m_bTimestamp != 0 ||*/
+                                              smart_feature_full->Internal.Inq1.m_bTimestamp2 != 0 ||
+                                              smart_feature_full->Internal.Inq3.m_bSIS != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->UserProfiles       = (smart_feature_full->Internal.Inq1.m_bUserProfiles != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->TriggerCounter     = (smart_feature_full->Internal.Inq1.m_bTrgCounter != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ParamListBuffer    = (smart_feature_full->Internal.Inq1.m_bParamListBuffer != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->GP_Buffer          = (smart_feature_full->Internal.Inq1.m_bGPBuffer != 0) ? DC1394_TRUE : DC1394_FALSE;
+
+    smart_feature_full->Input_1            = (smart_feature_full->Internal.Inq2.m_bInp_1 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_2            = (smart_feature_full->Internal.Inq2.m_bInp_2 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_3            = (smart_feature_full->Internal.Inq2.m_bInp_3 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_4            = (smart_feature_full->Internal.Inq2.m_bInp_4 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_5            = (smart_feature_full->Internal.Inq2.m_bInp_5 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_6            = (smart_feature_full->Internal.Inq2.m_bInp_6 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_7            = (smart_feature_full->Internal.Inq2.m_bInp_7 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Input_8            = (smart_feature_full->Internal.Inq2.m_bInp_8 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_1           = (smart_feature_full->Internal.Inq2.m_bOutp_1 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_2           = (smart_feature_full->Internal.Inq2.m_bOutp_2 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_3           = (smart_feature_full->Internal.Inq2.m_bOutp_3 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_4           = (smart_feature_full->Internal.Inq2.m_bOutp_4 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_5           = (smart_feature_full->Internal.Inq2.m_bOutp_5 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_6           = (smart_feature_full->Internal.Inq2.m_bOutp_6 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_7           = (smart_feature_full->Internal.Inq2.m_bOutp_7 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_8           = (smart_feature_full->Internal.Inq2.m_bOutp_8 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->IntEnaDelay        = (smart_feature_full->Internal.Inq2.m_bIntEnaDelay != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->IncDecoder         = (smart_feature_full->Internal.Inq2.m_bIncDecoder != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_1_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_1_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_2_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_2_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_3_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_3_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_4_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_4_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_5_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_5_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_6_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_6_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_7_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_7_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->Output_8_PWM       = (smart_feature_full->Internal.Inq2.m_bOutp_8_PWM != 0) ? DC1394_TRUE : DC1394_FALSE;
+
+    smart_feature_full->CameraStatus       = (smart_feature_full->Internal.Inq3.m_bCameraStatus != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ParamUpdTiming     = (smart_feature_full->Internal.Inq3.m_bParamUpdTiming != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->F7ModeMapping      = (smart_feature_full->Internal.Inq3.m_bF7ModeMapping != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->AutoShutter        = (smart_feature_full->Internal.Inq3.m_bAutoShutter != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->AutoGain           = (smart_feature_full->Internal.Inq3.m_bAutoGain != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->AutoFunctionAOI    = (smart_feature_full->Internal.Inq3.m_bAutoFncAOI != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->SequenceStep       = (smart_feature_full->Internal.Inq3.m_bSequenceStep != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->LowNoiseBinning    = (smart_feature_full->Internal.Inq3.m_bLowNoiseBinning != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->GlobalResetReleaseShutter = (smart_feature_full->Internal.Inq3.m_bGlobResRelShutter != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->DefectPixelCorrection     = (smart_feature_full->Internal.Inq3.m_bDpc != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->SWFeatureControl   = (smart_feature_full->Internal.Inq3.m_bSWFeatureCtrl != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_1    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_1 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_2    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_2 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_3    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_3 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_4    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_4 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_5    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_5 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_6    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_6 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_7    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_7 != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->InputDebounce_8    = (smart_feature_full->Internal.Inq3.m_bInpDebounce_8 != 0) ? DC1394_TRUE : DC1394_FALSE;
+
+    smart_feature_full->HDRPike            = (smart_feature_full->Internal.Inq4.m_bPikeHdrMode != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ChannelAdjustGain  = (smart_feature_full->Internal.Inq4.m_bPikeChannelComp != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->LowSmear           = (smart_feature_full->Internal.Inq4.m_bLowSmear != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->AdvWhiteBal        = (smart_feature_full->Internal.Inq4.m_bAdvWhiteBal != 0) ? DC1394_TRUE : DC1394_FALSE;
+    smart_feature_full->ChannelAdjustOffset=(smart_feature_full->Internal.Inq4.m_bPikeChannelOffset != 0) ? DC1394_TRUE : DC1394_FALSE;
+
+    /* older AVT cameras have the Autofunc AOI bit in Inq3 unset but do support AutofuncAOI -
+       also check the actual AutofuncAOI register */
+    if( DC1394_FALSE == smart_feature_full->AutoFunctionAOI )
+    {
+        dc1394error_t err;
+        dc1394_avt_csradv_autofnc_aoi_t sAFAOI;
+    
+        /* get register */
+        err=dc1394_get_adv_control_registers(camera,REG_CAMERA_AVT_AUTOFNC_AOI, (uint32_t*) &sAFAOI, 1);
+        DC1394_ERR_RTN(err,"Could not get AVT autofunction AOI Register");
+    
+        if( DC1394_SUCCESS == err && 0 != sAFAOI.m_Ctrl.m_bPresence )
+        {
+            smart_feature_full->AutoFunctionAOI = DC1394_TRUE;
+        }
+    }
+
+    if(smart_feature_full->SWFeatureControl==DC1394_TRUE)
+    {
+        dc1394_avt_csradv_swfeature_t sSWFeature;
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_SWFEATURE, 
+                                                 (uint32_t*) &sSWFeature,
+                                                 sizeof(dc1394_avt_csradv_swfeature_t)/4 );
+        smart_feature_full->LedBlanking = ( err==DC1394_SUCCESS && sSWFeature.m.m_bBlankLED_Inq!=0 )? DC1394_TRUE : DC1394_FALSE;
+    }
+    else
+    {
+        smart_feature_full->LedBlanking = DC1394_FALSE;
+    }
+
+    if(smart_feature_full->Internal.Inq3.m_bMaxIsoSize != 0)
+    {
+        dc1394_avt_csradv_max_isosize_t sMaxIso;
+
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_MAX_ISO_SIZE, 
+                                                 (uint32_t*) &sMaxIso,
+                                                 sizeof(dc1394_avt_csradv_max_isosize_t)/4 );
+        smart_feature_full->MaxIsoSize_S400 = ( err==DC1394_SUCCESS && sMaxIso.m_S400.m.m_bPresence!=0 )? DC1394_TRUE : DC1394_FALSE;
+        smart_feature_full->MaxIsoSize_S800 = ( err==DC1394_SUCCESS && sMaxIso.m_S800.m.m_bPresence!=0 )? DC1394_TRUE : DC1394_FALSE;
+    }
+    else
+    {
+        smart_feature_full->MaxIsoSize_S400 = DC1394_FALSE;
+        smart_feature_full->MaxIsoSize_S800 = DC1394_FALSE;
+    }
+    return DC1394_SUCCESS;
+}
+
+
 /************************************************************************/
-/* Print Advanced features                                                 */
+/* Print Advanced features - deprecated                                 */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_print_advanced_feature(dc1394_avt_adv_feature_info_t *adv_feature)
 {
-
     puts ("ADVANCED FEATURES SUPPORTED:");
     if(adv_feature->MaxResolution == DC1394_TRUE) puts (" MaxResolution ");
     if(adv_feature->TimeBase == DC1394_TRUE)         puts (" TimeBase ");
@@ -240,7 +533,6 @@
     //ADV_INQ_1 25-30
     if(adv_feature->GP_Buffer == DC1394_TRUE)         puts (" GP_Buffer ");
 
-
     if(adv_feature->Input_1 == DC1394_TRUE)        puts (" Input_1 ");
     if(adv_feature->Input_2 == DC1394_TRUE)         puts (" Input_2 ");
     //ADV_INQ_2 2-7
@@ -269,7 +561,104 @@
 
 
 /************************************************************************/
-/* Get shading mode                                                        */
+/* Print Smart features                                                 */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_print_smart_features(dc1394_avt_smart_feature_info_t *adv_feature)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>adv_feature->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    puts ("ADVANCED FEATURES SUPPORTED:");
+    if(adv_feature->MaxResolution == DC1394_TRUE)       puts (" MaxResolution ");
+    if(adv_feature->TimeBase == DC1394_TRUE)            puts (" TimeBase ");
+    if(adv_feature->ExtdShutter == DC1394_TRUE)         puts (" ExtdShutter ");
+    if(adv_feature->TestImage == DC1394_TRUE)           puts (" TestImage ");
+    if(adv_feature->FrameCounter == DC1394_TRUE)        puts (" FrameCounter ");
+    if(adv_feature->Sequences == DC1394_TRUE)           puts (" Sequences ");
+    if(adv_feature->VersionInfo == DC1394_TRUE)         puts (" VersionInfo ");
+    if(adv_feature->Lookup_Tables == DC1394_TRUE)       puts (" Lookup_Tables ");
+    if(adv_feature->Shading == DC1394_TRUE)             puts (" Shading ");
+    if(adv_feature->DeferredTransport == DC1394_TRUE)   puts (" DeferredTransport ");
+    if(adv_feature->HDR_Mode == DC1394_TRUE)            puts (" HDR_Mode ");
+    if(adv_feature->DSNU == DC1394_TRUE)                puts (" DSNU ");
+    if(adv_feature->BlemishCorrection == DC1394_TRUE)   puts (" BlemishCorrection ");
+    if(adv_feature->TriggerDelay == DC1394_TRUE)        puts (" TriggerDelay ");
+    if(adv_feature->MirrorImage == DC1394_TRUE)         puts (" MirrorImage ");
+    if(adv_feature->SoftReset == DC1394_TRUE)           puts (" SoftReset ");
+    if(adv_feature->HSNR == DC1394_TRUE)                puts (" HSNR ");
+    if(adv_feature->ColorCorrection == DC1394_TRUE)     puts (" ColorCorrection ");
+    if(adv_feature->ColorAvg == DC1394_TRUE)            puts (" ColorAvg ");
+    if(adv_feature->SIS == DC1394_TRUE)                 puts (" SIS ");
+    if(adv_feature->UserProfiles == DC1394_TRUE)        puts (" UserProfiles ");
+    if(adv_feature->TriggerCounter == DC1394_TRUE)      puts (" TriggerCounter ");
+    if(adv_feature->ParamListBuffer == DC1394_TRUE)     puts (" ParamListBuffer ");
+    if(adv_feature->GP_Buffer == DC1394_TRUE)           puts (" GP_Buffer ");
+
+    if(adv_feature->Input_1 == DC1394_TRUE)             puts (" Input_1 ");
+    if(adv_feature->Input_2 == DC1394_TRUE)             puts (" Input_2 ");
+    if(adv_feature->Input_3 == DC1394_TRUE)             puts (" Input_3 ");
+    if(adv_feature->Input_4 == DC1394_TRUE)             puts (" Input_4 ");
+    if(adv_feature->Input_5 == DC1394_TRUE)             puts (" Input_5 ");
+    if(adv_feature->Input_6 == DC1394_TRUE)             puts (" Input_6 ");
+    if(adv_feature->Input_7 == DC1394_TRUE)             puts (" Input_7 ");
+    if(adv_feature->Input_8 == DC1394_TRUE)             puts (" Input_8 ");
+    if(adv_feature->Output_1 == DC1394_TRUE)            puts (" Output_1 ");
+    if(adv_feature->Output_2 == DC1394_TRUE)            puts (" Output_2 ");
+    if(adv_feature->Output_3 == DC1394_TRUE)            puts (" Output_3 ");
+    if(adv_feature->Output_4 == DC1394_TRUE)            puts (" Output_4 ");
+    if(adv_feature->Output_5 == DC1394_TRUE)            puts (" Output_5 ");
+    if(adv_feature->Output_6 == DC1394_TRUE)            puts (" Output_6 ");
+    if(adv_feature->Output_7 == DC1394_TRUE)            puts (" Output_7 ");
+    if(adv_feature->Output_8 == DC1394_TRUE)            puts (" Output_8 ");
+    if(adv_feature->IntEnaDelay == DC1394_TRUE)         puts (" IntEnaDelay ");
+    if(adv_feature->IncDecoder == DC1394_TRUE)          puts (" IncDecoder ");
+    if(adv_feature->Output_1_PWM == DC1394_TRUE)        puts (" Output_1_PWM ");
+    if(adv_feature->Output_2_PWM == DC1394_TRUE)        puts (" Output_2_PWM ");
+    if(adv_feature->Output_3_PWM == DC1394_TRUE)        puts (" Output_3_PWM ");
+    if(adv_feature->Output_4_PWM == DC1394_TRUE)        puts (" Output_4_PWM ");
+    if(adv_feature->Output_5_PWM == DC1394_TRUE)        puts (" Output_5_PWM ");
+    if(adv_feature->Output_6_PWM == DC1394_TRUE)        puts (" Output_6_PWM ");
+    if(adv_feature->Output_7_PWM == DC1394_TRUE)        puts (" Output_7_PWM ");
+    if(adv_feature->Output_8_PWM == DC1394_TRUE)        puts (" Output_8_PWM ");
+
+    if(adv_feature->CameraStatus == DC1394_TRUE)        puts (" CameraStatus ");
+    if(adv_feature->MaxIsoSize_S400 == DC1394_TRUE)     puts (" MaxIsoSize_S400 ");
+    if(adv_feature->MaxIsoSize_S800 == DC1394_TRUE)     puts (" MaxIsoSize_S800 ");
+    if(adv_feature->ParamUpdTiming == DC1394_TRUE)      puts (" ParamUpdTiming ");
+    if(adv_feature->F7ModeMapping == DC1394_TRUE)       puts (" F7ModeMapping ");
+    if(adv_feature->AutoShutter == DC1394_TRUE)         puts (" AutoShutter ");
+    if(adv_feature->AutoGain == DC1394_TRUE)            puts (" AutoGain ");
+    if(adv_feature->AutoFunctionAOI == DC1394_TRUE)     puts (" AutoFunctionAOI ");
+    if(adv_feature->SequenceStep == DC1394_TRUE)        puts (" SequenceStep ");
+    if(adv_feature->LowNoiseBinning == DC1394_TRUE)     puts (" LowNoiseBinning ");
+
+    if(adv_feature->GlobalResetReleaseShutter == DC1394_TRUE) puts (" GlobalResetReleaseShutter ");
+    if(adv_feature->DefectPixelCorrection == DC1394_TRUE)     puts (" DefectPixelCorrection ");
+    if(adv_feature->SWFeatureControl == DC1394_TRUE)    puts (" SWFeatureControl ");
+    if(adv_feature->LedBlanking == DC1394_TRUE)         puts (" LedBlanking ");
+    if(adv_feature->InputDebounce_1 == DC1394_TRUE)     puts (" InputDebounce_1 ");
+    if(adv_feature->InputDebounce_2 == DC1394_TRUE)     puts (" InputDebounce_2 ");
+    if(adv_feature->InputDebounce_3 == DC1394_TRUE)     puts (" InputDebounce_3 ");
+    if(adv_feature->InputDebounce_4 == DC1394_TRUE)     puts (" InputDebounce_4 ");
+    if(adv_feature->InputDebounce_5 == DC1394_TRUE)     puts (" InputDebounce_5 ");
+    if(adv_feature->InputDebounce_6 == DC1394_TRUE)     puts (" InputDebounce_6 ");
+    if(adv_feature->InputDebounce_7 == DC1394_TRUE)     puts (" InputDebounce_7 ");
+    if(adv_feature->InputDebounce_8 == DC1394_TRUE)     puts (" InputDebounce_8 ");
+
+    if(adv_feature->HDRPike == DC1394_TRUE)             puts (" HDRPike ");
+    if(adv_feature->ChannelAdjustGain == DC1394_TRUE)   puts (" ChannelAdjustGain ");
+    if(adv_feature->LowSmear == DC1394_TRUE)            puts (" LowSmear ");
+    if(adv_feature->AdvWhiteBal == DC1394_TRUE)         puts (" AdvWhiteBal ");
+    if(adv_feature->ChannelAdjustOffset == DC1394_TRUE) puts (" ChannelAdjustOffset ");
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get shading correction feature - deprecated                          */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_shading(dc1394camera_t *camera,
@@ -305,7 +694,39 @@
 
 
 /************************************************************************/
-/* Set shading mode                                                        */
+/* Get shading correction feature                                       */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_shading_correction(dc1394camera_t *camera,
+                                                dc1394switch_t *on_off,
+                                                dc1394bool_t *build_err,
+                                                dc1394switch_t *show, 
+                                                uint32_t *frame_nb,
+                                                uint32_t *mem_channel,
+                                                uint32_t *mem_channel_err)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_shading_t sShading;
+
+    /* Retrieve shading registers */
+    err=dc1394_get_adv_control_registers( camera,
+                                          REG_CAMERA_AVT_SHDG_CTRL, 
+                                          (uint32_t*) &sShading, 
+                                          sizeof(dc1394_avt_csradv_shading_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
+
+    *on_off = (sShading.m_Ctrl.m_bOnOff!=0) ? DC1394_ON : DC1394_OFF;
+    *build_err = (sShading.m_Ctrl.m_bBuildError!=0) ? DC1394_TRUE : DC1394_FALSE;
+    *show = (sShading.m_Ctrl.m_bShowImg!=0) ? DC1394_ON : DC1394_OFF;
+    *frame_nb = sShading.m_Ctrl.m_nGrabCount;
+    *mem_channel = sShading.m_Ctrl.m_nMemChn;
+    *mem_channel_err = sShading.m_Ctrl.m_nMemChnError;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set shading correction feature - deprecated                          */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_shading(dc1394camera_t *camera,
@@ -313,30 +734,97 @@
                        dc1394bool_t show, uint32_t frame_nb)
 {
     dc1394error_t err;
-    uint32_t curval;
+    dc1394_avt_csradv_shading_t sShading;
 
     /* Retrieve current shading properties */
-    err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_SHDG_CTRL, &curval);
+    err=dc1394_get_adv_control_registers( camera,
+                                          REG_CAMERA_AVT_SHDG_CTRL, 
+                                          (uint32_t*) &sShading, 
+                                          1 );
     DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
 
     /* Shading ON / OFF : Bit 6 */
-    curval = (curval & 0xFDFFFFFFUL) | ((on_off ) << 25);
+    sShading.m_Ctrl.m_bOnOff = (on_off==DC1394_TRUE)? 1:0;
 
     /* Compute : Bit 5 */
-    curval = (curval & 0xFBFFFFFFUL) | ((compute ) << 26);
+    sShading.m_Ctrl.m_bBuildTable = (compute==DC1394_TRUE)? 1:0;
 
     /* Show Image : Bit 4 */
-    curval = (curval & 0xF7FFFFFFUL) | ((show ) << 27);
+    sShading.m_Ctrl.m_bShowImg = (show==DC1394_TRUE)? 1:0;
 
     /* Number of images : Bits 24..31 */
-    curval = (curval & 0xFFFFFF00UL) | ((frame_nb & 0xFFUL ));
+    sShading.m_Ctrl.m_nGrabCount = frame_nb;
 
     /* Set new parameters */
-    err=dc1394_set_adv_control_register(camera,REG_CAMERA_AVT_SHDG_CTRL, curval);
+    err=dc1394_set_adv_control_registers(camera,REG_CAMERA_AVT_SHDG_CTRL,(uint32_t*) &sShading,1);
     DC1394_ERR_RTN(err,"Could not set AVT shading control reg");
 
+    /* Poll register until busy is cleared */
+    do
+    {
+        usleep(500000);
+        err=dc1394_get_adv_control_registers( camera,
+                                              REG_CAMERA_AVT_SHDG_CTRL, 
+                                              (uint32_t*) &sShading, 
+                                              1 );
+        DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
+    } while( sShading.m_Ctrl.m_bBusy != 0 );
+
     return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set shading correction feature                                       */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_shading_correction(dc1394camera_t *camera,
+                                                dc1394switch_t on_off, 
+                                                dc1394switch_t compute,
+                                                dc1394switch_t show, 
+                                                uint32_t frame_nb,
+                                                uint32_t mem_channel,
+                                                dc1394switch_t mem_clear,
+                                                dc1394switch_t mem_load,
+                                                dc1394switch_t mem_save)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_shading_t sShading;
+
+    /* Retrieve shading registers */
+    err=dc1394_get_adv_control_registers( camera,
+                                          REG_CAMERA_AVT_SHDG_CTRL, 
+                                          (uint32_t*) &sShading, 
+                                          sizeof(dc1394_avt_csradv_shading_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
 
+    sShading.m_Ctrl.m_bOnOff      = (DC1394_ON==on_off)? 1 : 0;
+    sShading.m_Ctrl.m_bBuildTable = (DC1394_ON==compute)? 1 : 0;
+    sShading.m_Ctrl.m_bShowImg    = (DC1394_ON==show)? 1 : 0;
+    sShading.m_Ctrl.m_nGrabCount  = frame_nb;
+    sShading.m_Ctrl.m_nMemChn     = mem_channel;
+    sShading.m_Ctrl.m_bMemClear   = (DC1394_ON==mem_clear)? 1 : 0;
+    sShading.m_Ctrl.m_bMemLoad    = (DC1394_ON==mem_load)? 1 : 0;
+    sShading.m_Ctrl.m_bMemSave    = (DC1394_ON==mem_save)? 1 : 0;
+
+    /* write back register */
+    err=dc1394_set_adv_control_registers( camera,
+                                          REG_CAMERA_AVT_SHDG_CTRL, 
+                                          (uint32_t*) &sShading, 
+                                          1 );
+    DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
+
+    /* poll camera until busy bit is cleared */
+    do
+    {
+        usleep(500000);
+        err=dc1394_get_adv_control_registers( camera,
+                                              REG_CAMERA_AVT_SHDG_CTRL, 
+                                              (uint32_t*) &sShading, 
+                                              sizeof(dc1394_avt_csradv_shading_t)/4 );
+        DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
+    } while (sShading.m_Ctrl.m_bBusy!=0);
+
+    return DC1394_SUCCESS;
 }
 
 
@@ -400,8 +888,9 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Get shading  info                                                        */
+/* Get shading info - deprecated                                        */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_shading_info(dc1394camera_t *camera, uint32_t *MaxImageSize)
@@ -422,7 +911,31 @@
 
 
 /************************************************************************/
-/* Get Multiple slope parameters        (HDR)                                */
+/* Get shading correction info                                          */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_shading_correction_info(dc1394camera_t *camera,
+                                                     uint32_t *MaxImageSize,
+                                                     uint32_t *MemChannelCount)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_shading_t sShading;
+
+    /* Retrieve shading registers */
+    err=dc1394_get_adv_control_registers( camera,
+                                          REG_CAMERA_AVT_SHDG_CTRL, 
+                                          (uint32_t*) &sShading, 
+                                          sizeof(dc1394_avt_csradv_shading_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT shading control reg");
+
+    *MaxImageSize = sShading.m_Info.m_nMaxSize;
+    *MemChannelCount = sShading.m_Info.m_nMemChnCount;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Multiple slope parameters (HDR)                                  */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_multiple_slope(dc1394camera_t *camera,
@@ -513,7 +1026,7 @@
 
 
 /************************************************************************/
-/* Set Shutter Timebase (acquisition must be stopped)                        */
+/* Set Shutter Timebase (acquisition must be stopped)                   */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_timebase(dc1394camera_t *camera, uint32_t timebase_id)
@@ -536,7 +1049,7 @@
 
 
 /************************************************************************/
-/* Get Extented Shutter                                                  */
+/* Get Extented Shutter                                                 */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_extented_shutter(dc1394camera_t *camera, uint32_t *timebase_id)
@@ -557,7 +1070,7 @@
 
 
 /************************************************************************/
-/* Set Extented shutter                                                        */
+/* Set Extented shutter                                                 */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_extented_shutter(dc1394camera_t *camera, uint32_t timebase_id)
@@ -581,7 +1094,7 @@
 
 
 /************************************************************************/
-/* Get MaxResolution          (Read Only)                                        */
+/* Get MaxResolution          (Read Only)                               */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_MaxResolution(dc1394camera_t *camera, uint32_t *MaxHeight, uint32_t *MaxWidth)
@@ -603,7 +1116,7 @@
 
 
 /************************************************************************/
-/* Get Auto Shutter                                                          */
+/* Get Auto Shutter                                                     */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_auto_shutter(dc1394camera_t *camera, uint32_t *MinValue, uint32_t *MaxValue)
@@ -628,7 +1141,7 @@
 
 
 /************************************************************************/
-/* Set Auto shutter                                                        */
+/* Set Auto shutter                                                     */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_auto_shutter(dc1394camera_t *camera, uint32_t MinValue, uint32_t MaxValue)
@@ -647,7 +1160,7 @@
 
 
 /************************************************************************/
-/* Get Auto Gain                                                          */
+/* Get Auto Gain                                                        */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_auto_gain(dc1394camera_t *camera, uint32_t *MinValue, uint32_t *MaxValue)
@@ -689,7 +1202,7 @@
 
 
 /************************************************************************/
-/* Get Trigger delay                                                        */
+/* Get Trigger delay                                                    */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_trigger_delay(dc1394camera_t *camera, dc1394bool_t *on_off, uint32_t *DelayTime)
@@ -712,7 +1225,7 @@
 
 
 /************************************************************************/
-/* Set Trigger delay                                                        */
+/* Set Trigger delay                                                    */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_trigger_delay(dc1394camera_t *camera, dc1394bool_t on_off, uint32_t DelayTime)
@@ -739,7 +1252,7 @@
 
 
 /************************************************************************/
-/* Get Mirror                                                                 */
+/* Get Mirror                                                           */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_mirror(dc1394camera_t *camera, dc1394bool_t *on_off)
@@ -757,8 +1270,9 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Set Mirror                                                                */
+/* Set Mirror                                                           */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_mirror(dc1394camera_t *camera, dc1394bool_t on_off)
@@ -776,8 +1290,9 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Get DSNU                                                                 */
+/* Get DSNU - deprecated                                                */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_dsnu(dc1394camera_t *camera, dc1394bool_t *on_off,uint32_t *frame_nb)
@@ -797,8 +1312,37 @@
     return DC1394_SUCCESS;
 }
 
+
+/************************************************************************/
+/* Get DSNU correction                                                  */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_dsnu_correction(dc1394camera_t *camera,
+                                             dc1394switch_t *on_off,
+                                             dc1394bool_t   *build_error,
+                                             uint32_t       *frame_nb,
+                                             dc1394switch_t *show_image)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_dsnucorrection_t sDSNU;
+
+    /* Retrieve dsnu config */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DSNU_CONTROL, 
+                                             (uint32_t*) &sDSNU,
+                                             sizeof(dc1394_avt_csradv_dsnucorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT DSNU control");
+
+    *on_off = (sDSNU.m.m_bOnOff != 0) ? DC1394_ON : DC1394_OFF;
+    *build_error = (sDSNU.m.m_bBuildError != 0) ? DC1394_TRUE : DC1394_FALSE;
+    *frame_nb = sDSNU.m.m_nGrabCount;
+    *show_image = (sDSNU.m.m_bShowImg != 0) ? DC1394_ON : DC1394_OFF;
+
+    return err;
+}
+
+
 /************************************************************************/
-/* Set DSNU                                                                */
+/* Set DSNU - deprecated                                                */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_dsnu(dc1394camera_t *camera,
@@ -836,7 +1380,57 @@
 }
 
 /************************************************************************/
-/* Get BLEMISH                                                                 */
+/* Set DSNU correction                                                  */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_dsnu_correction(dc1394camera_t *camera,
+                                             dc1394switch_t on_off, 
+                                             dc1394switch_t compute_image,
+                                             uint32_t       frame_nb,
+                                             dc1394switch_t show_image,
+                                             dc1394switch_t load_image,
+                                             dc1394switch_t save_image)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_dsnucorrection_t sDSNU;
+
+    /* Retrieve dsnu register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DSNU_CONTROL, 
+                                             (uint32_t*) &sDSNU,
+                                             sizeof(dc1394_avt_csradv_dsnucorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT DSNU control");
+
+    sDSNU.m.m_bOnOff = (on_off==DC1394_ON) ? 1 : 0;
+    sDSNU.m.m_bBuildTable = (compute_image==DC1394_ON) ? 1 : 0;
+    sDSNU.m.m_nGrabCount = frame_nb;
+    sDSNU.m.m_bShowImg = (show_image==DC1394_ON) ? 1 : 0;
+    sDSNU.m.m_bMemLoad = (load_image==DC1394_ON) ? 1 : 0;
+    sDSNU.m.m_bMemSave = (save_image==DC1394_ON) ? 1 : 0;
+
+    /* Write back dsnu register */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             REG_CAMERA_AVT_DSNU_CONTROL, 
+                                             (uint32_t*) &sDSNU, 
+                                             sizeof(dc1394_avt_csradv_dsnucorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT DSNU control");
+
+    /* wait until busy flag is cleared */
+    int cont=1;
+    while (cont) {
+        usleep(50000);
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_DSNU_CONTROL, 
+                                                 (uint32_t*) &sDSNU,
+                                                 sizeof(dc1394_avt_csradv_dsnucorrection_t)/4 );
+        DC1394_ERR_RTN(err,"Could not get AVT DSNU control");
+        if (sDSNU.m.m_bBusy==0)
+            cont=0;
+    }
+    return err;
+}
+
+/************************************************************************/
+/* Get BLEMISH - deprecated                                             */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_blemish(dc1394camera_t *camera, dc1394bool_t *on_off, uint32_t *frame_nb)
@@ -857,7 +1451,34 @@
 }
 
 /************************************************************************/
-/* Set BLEMISH                                                                */
+/* Get blemish pixel correction                                         */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_blemish_correction(dc1394camera_t *camera,
+                                                dc1394switch_t *on_off,
+                                                dc1394bool_t   *build_error,
+                                                uint32_t       *frame_nb,
+                                                dc1394switch_t *show_image)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_blemishcorrection_t sBlemish;
+
+    /* Retrieve dsnu config */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_BLEMISH_CONTROL, 
+                                             (uint32_t*) &sBlemish,
+                                             sizeof(dc1394_avt_csradv_blemishcorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT blemish control");
+
+    *on_off = (sBlemish.m.m_bOnOff != 0) ? DC1394_ON : DC1394_OFF;
+    *build_error = (sBlemish.m.m_bBuildError != 0) ? DC1394_TRUE : DC1394_FALSE;
+    *frame_nb = sBlemish.m.m_nGrabCount;
+    *show_image = (sBlemish.m.m_bShowImg != 0) ? DC1394_ON : DC1394_OFF;
+
+    return err;
+}
+
+/************************************************************************/
+/* Set BLEMISH - deprecated                                             */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_blemish(dc1394camera_t *camera,
@@ -895,10 +1516,58 @@
     return DC1394_SUCCESS;
 }
 
+/************************************************************************/
+/* Set blemish pixel correction                                         */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_blemish_correction(dc1394camera_t *camera,
+                                                dc1394switch_t on_off, 
+                                                dc1394switch_t compute_image,
+                                                uint32_t       frame_nb,
+                                                dc1394switch_t show_image,
+                                                dc1394switch_t load_image,
+                                                dc1394switch_t save_image)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_blemishcorrection_t sBlemish;
+
+    /* Retrieve dsnu register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_BLEMISH_CONTROL, 
+                                             (uint32_t*) &sBlemish,
+                                             sizeof(dc1394_avt_csradv_blemishcorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT blemish control");
+
+    sBlemish.m.m_bOnOff = (on_off==DC1394_ON) ? 1 : 0;
+    sBlemish.m.m_bBuildTable = (compute_image==DC1394_ON) ? 1 : 0;
+    sBlemish.m.m_nGrabCount = frame_nb;
+    sBlemish.m.m_bShowImg = (show_image==DC1394_ON) ? 1 : 0;
+    sBlemish.m.m_bMemLoad = (load_image==DC1394_ON) ? 1 : 0;
+    sBlemish.m.m_bMemSave = (save_image==DC1394_ON) ? 1 : 0;
+
+    /* Write back dsnu register */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             REG_CAMERA_AVT_BLEMISH_CONTROL, 
+                                             (uint32_t*) &sBlemish, 
+                                             sizeof(dc1394_avt_csradv_blemishcorrection_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT blemish control");
 
+    /* wait until busy flag is cleared */
+    int cont=1;
+    while (cont) {
+        usleep(50000);
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_BLEMISH_CONTROL, 
+                                                 (uint32_t*) &sBlemish,
+                                                 sizeof(dc1394_avt_csradv_blemishcorrection_t)/4 );
+        DC1394_ERR_RTN(err,"Could not get AVT blemish control");
+        if (sBlemish.m.m_bBusy==0)
+            cont=0;
+    }
+    return err;
+}
 
 /************************************************************************/
-/* Get IO   REG_CAMERA_AVT_IO_INP_CTRLx        or REG_CAMERA_AVT_IO_OUTP_CTRLx        */
+/* Get IO                                                               */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_io(dc1394camera_t *camera, uint32_t IO,
@@ -907,6 +1576,30 @@
     dc1394error_t err;
     uint32_t value;
 
+    /* check that param IO is valid */
+    switch(IO)
+    {
+        case REG_CAMERA_AVT_IO_INP_CTRL1:
+        case REG_CAMERA_AVT_IO_INP_CTRL2:
+        case REG_CAMERA_AVT_IO_INP_CTRL3:
+        case REG_CAMERA_AVT_IO_INP_CTRL4:
+        case REG_CAMERA_AVT_IO_INP_CTRL5:
+        case REG_CAMERA_AVT_IO_INP_CTRL6:
+        case REG_CAMERA_AVT_IO_INP_CTRL7:
+        case REG_CAMERA_AVT_IO_INP_CTRL8:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL1:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL2:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL3:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL4:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL5:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL6:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL7:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
     /* Retrieve IO parameters */
     err=dc1394_get_adv_control_register(camera,IO, &value);
     DC1394_ERR_RTN(err,"Could not get AVT IO register");
@@ -924,7 +1617,7 @@
 }
 
 /************************************************************************/
-/* Set IO   REG_CAMERA_AVT_IO_INP_CTRLx        or REG_CAMERA_AVT_IO_OUTP_CTRLx        */
+/* Set IO                                                               */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_io(dc1394camera_t *camera,uint32_t IO,
@@ -933,6 +1626,30 @@
     dc1394error_t err;
     uint32_t curval;
 
+    /* check that param IO is valid */
+    switch(IO)
+    {
+        case REG_CAMERA_AVT_IO_INP_CTRL1:
+        case REG_CAMERA_AVT_IO_INP_CTRL2:
+        case REG_CAMERA_AVT_IO_INP_CTRL3:
+        case REG_CAMERA_AVT_IO_INP_CTRL4:
+        case REG_CAMERA_AVT_IO_INP_CTRL5:
+        case REG_CAMERA_AVT_IO_INP_CTRL6:
+        case REG_CAMERA_AVT_IO_INP_CTRL7:
+        case REG_CAMERA_AVT_IO_INP_CTRL8:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL1:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL2:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL3:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL4:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL5:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL6:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL7:
+        case REG_CAMERA_AVT_IO_OUTP_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
     /* Retrieve current IO parameters */
     err=dc1394_get_adv_control_register(camera,IO, &curval);
     DC1394_ERR_RTN(err,"Could not get AVT IO register");
@@ -955,7 +1672,258 @@
 }
 
 /************************************************************************/
-/* BusReset IEEE1394                                                        */
+/* Get PWM IO Info                                                      */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_io_pwmout_info(dc1394camera_t *camera,
+                                            uint32_t       pwm_output_pin, 
+                                            uint32_t       *min_period)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_outp_pwmx_t sPWM;
+
+    /* check that param pwm_output_pin is valid */
+    switch(pwm_output_pin)
+    {
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL1:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL2:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL3:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL4:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL5:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL6:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL7:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get register */
+    err=dc1394_get_adv_control_registers(camera, pwm_output_pin, (uint32_t*) &sPWM, 1);
+    DC1394_ERR_RTN(err,"Could not get AVT PWM Output register");
+
+    /* copy inquiry data */
+    *min_period = sPWM.m_Ctrl.m_nMinPeriod;
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* Get PWM IO                                                           */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_io_pwmout(dc1394camera_t *camera,
+                                       uint32_t       pwm_output_pin, 
+                                       uint32_t       *period,
+                                       uint32_t       *pulse_width)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_outp_pwmx_t sPWM;
+
+    /* check that param pwm_output_pin is valid */
+    switch(pwm_output_pin)
+    {
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL1:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL2:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL3:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL4:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL5:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL6:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL7:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get register */
+    err=dc1394_get_adv_control_registers(camera, 
+                                         pwm_output_pin, 
+                                         (uint32_t*) &sPWM, 
+                                         sizeof(dc1394_avt_csradv_io_outp_pwmx_t)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT PWM Output register");
+
+    /* read feature state */
+    *period      = sPWM.m_Pwm.m_nPeriod;
+    *pulse_width = sPWM.m_Pwm.m_nPulseWidth;
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* Set PWM IO                                                           */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_io_pwmout(dc1394camera_t *camera,
+                                       uint32_t       pwm_output_pin, 
+                                       uint32_t       period,
+                                       uint32_t       pulse_width)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_outp_pwmx_t sPWM;
+
+    /* check that param pwm_output_pin is valid */
+    switch(pwm_output_pin)
+    {
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL1:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL2:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL3:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL4:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL5:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL6:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL7:
+        case REG_CAMERA_AVT_IO_OUTP_PWM_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get register */
+    err=dc1394_get_adv_control_registers(camera, 
+                                         pwm_output_pin, 
+                                         (uint32_t*) &sPWM, 
+                                         sizeof(dc1394_avt_csradv_io_outp_pwmx_t)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT PWM Output register");
+
+    /* set feature state */
+    sPWM.m_Pwm.m_nPeriod = period;
+    sPWM.m_Pwm.m_nPulseWidth = pulse_width;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             pwm_output_pin, 
+                                             (uint32_t*) &sPWM, 
+                                             sizeof(dc1394_avt_csradv_io_outp_pwmx_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT PWM Output register");
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* Get Input Debounce Info                                              */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_io_inp_debounce_info(dc1394camera_t *camera,
+                                                  uint32_t       debounce_inp_pin,
+                                                  uint32_t       *min_debounce_time,
+                                                  uint32_t       *max_debounce_time)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_inp_debounce_x sDebounce;
+
+    /* check that param debounce_inp_pin is valid */
+    switch(debounce_inp_pin)
+    {
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL1:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL2:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL3:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL4:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL5:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL6:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL7:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get registers */
+    err=dc1394_get_adv_control_registers(camera, 
+                                         debounce_inp_pin, 
+                                         (uint32_t*) &sDebounce, 
+                                         sizeof(dc1394_avt_csradv_io_inp_debounce_x)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT Input Debounce register");
+
+    /* read feature info */
+    *min_debounce_time = sDebounce.m_nMinDebTime;
+    *max_debounce_time = sDebounce.m_nMaxDebTime;
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* Get Input Debounce                                                   */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_io_inp_debounce(dc1394camera_t *camera,
+                                             uint32_t       debounce_inp_pin,
+                                             uint32_t       *debounce_time)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_inp_debounce_x sDebounce;
+
+    /* check that param debounce_inp_pin is valid */
+    switch(debounce_inp_pin)
+    {
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL1:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL2:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL3:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL4:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL5:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL6:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL7:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get registers */
+    err=dc1394_get_adv_control_registers(camera, 
+                                         debounce_inp_pin, 
+                                         (uint32_t*) &sDebounce, 
+                                         sizeof(dc1394_avt_csradv_io_inp_debounce_x)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT Input Debounce register");
+
+    /* read feature config */
+    *debounce_time = sDebounce.m_Ctrl.m.m_nDebTime;
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* Set Input Debounce                                                   */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_io_inp_debounce(dc1394camera_t *camera,
+                                             uint32_t       debounce_inp_pin,
+                                             uint32_t       debounce_time)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_io_inp_debounce_x sDebounce;
+
+    /* check that param debounce_inp_pin is valid */
+    switch(debounce_inp_pin)
+    {
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL1:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL2:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL3:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL4:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL5:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL6:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL7:
+        case REG_CAMERA_AVT_IO_INP_DEBOUNCE_CTRL8:
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* get registers */
+    err=dc1394_get_adv_control_registers(camera, 
+                                         debounce_inp_pin, 
+                                         (uint32_t*) &sDebounce, 
+                                         sizeof(dc1394_avt_csradv_io_inp_debounce_x)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT Input Debounce register");
+
+    /* read feature config */
+    sDebounce.m_Ctrl.m.m_nDebTime = debounce_time;
+
+    /* write back registers */
+    err=dc1394_set_adv_control_registers(camera, 
+                                         debounce_inp_pin, 
+                                         (uint32_t*) &sDebounce, 
+                                         sizeof(dc1394_avt_csradv_io_inp_debounce_x)/4);
+    DC1394_ERR_RTN(err,"Could not set AVT Input Debounce register");
+
+    return DC1394_SUCCESS;
+}
+
+/************************************************************************/
+/* BusReset IEEE1394                                                    */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_reset(dc1394camera_t *camera)
@@ -973,7 +1941,7 @@
 
 
 /************************************************************************/
-/* Get Lookup Tables (LUT)                                                */
+/* Get Lookup Tables (LUT)                                              */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_lut(dc1394camera_t *camera, dc1394bool_t *on_off, uint32_t *lutnb)
@@ -996,7 +1964,7 @@
 
 
 /************************************************************************/
-/* Set Lookup Tables (LUT)                                                */
+/* Set Lookup Tables (LUT)                                              */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_lut(dc1394camera_t *camera, dc1394bool_t on_off, uint32_t lutnb)
@@ -1023,7 +1991,7 @@
 
 
 /************************************************************************/
-/* Get LUT ctrl                                                                */
+/* Get LUT ctrl                                                         */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_lut_mem_ctrl(dc1394camera_t *camera, dc1394bool_t *en_write,
@@ -1081,7 +2049,7 @@
 
 
 /************************************************************************/
-/* Get LUT  info                                                        */
+/* Get LUT  info - deprecated                                           */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_lut_info(dc1394camera_t *camera, uint32_t *NumOfLuts, uint32_t *MaxLutSize)
@@ -1102,9 +2070,74 @@
 }
 
 
+/************************************************************************/
+/* Get Extd. LUT info                                                   */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_lut_extd_info(dc1394camera_t *camera, 
+                                           uint32_t       *NumOfLuts, 
+                                           uint32_t       *MaxValue,
+                                           uint32_t       *NumOfValues,
+                                           uint32_t       *MaxLutSize)
+{
+    dc1394error_t err;
+
+    /* get register */
+    dc1394_avt_csradv_lut_ctrl_t sLut;
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LUT_CTRL, 
+                                             (uint32_t*) &sLut,
+                                             sizeof(dc1394_avt_csradv_lut_ctrl_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature LUT");
+
+    /* find out bits per value */
+    dc1394_avt_family_t eFamily = (dc1394_avt_family_t) ( ( camera->guid >> 24 ) & 0xff );
+    uint32_t bitsPerVal;
+    switch ( eFamily )
+    {
+        case DC1394_AVT_FAMILY_DOLPHIN_OLD:
+        case DC1394_AVT_FAMILY_DOLPHIN:
+            /* Dolphin cameras do not support BitsPerValue inquiry, they have always 10 bpv */
+            bitsPerVal = 10;
+            break;
+        default:
+            bitsPerVal = sLut.m_Info.m_nBitsPerValue;
+            break;
+    }
+
+    /* return info */
+    *NumOfLuts = sLut.m_Info.m_nNumOfLuts;
+    *MaxValue = (1<<bitsPerVal)-1;
+    *NumOfValues = (bitsPerVal<=8)? sLut.m_Info.m_nMaxSize : sLut.m_Info.m_nMaxSize/2;
+    *MaxLutSize = sLut.m_Info.m_nMaxSize;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Autofunction AOI Info                                            */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_autofunc_aoi_info(dc1394camera_t *camera,
+                                               uint32_t       *unit_x, 
+                                               uint32_t       *unit_y)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_autofnc_aoi_t sAFAOI;
+
+    /* get register */
+    err=dc1394_get_adv_control_registers(camera,REG_CAMERA_AVT_AUTOFNC_AOI, (uint32_t*) &sAFAOI, 1);
+    DC1394_ERR_RTN(err,"Could not get AVT autofunction AOI Register");
+
+    /* read units - 128 is the default unit size when unit inquiries are set to 0 */
+    *unit_x = (sAFAOI.m_Ctrl.m_nXUnits==0)? 128 : sAFAOI.m_Ctrl.m_nXUnits;
+    *unit_y = (sAFAOI.m_Ctrl.m_nYUnits==0)? 128 : sAFAOI.m_Ctrl.m_nYUnits;
+
+    return DC1394_SUCCESS;
+}
+
 
 /************************************************************************/
-/* Get Automatic white balance        with Area Of Interest AOI                */
+/* Get Autofunction AOI - deprecated                                    */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_aoi(dc1394camera_t *camera,
@@ -1141,8 +2174,42 @@
     return DC1394_SUCCESS;
 }
 
+
+/************************************************************************/
+/* Get Autofunction AOI                                                 */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_autofunc_aoi(dc1394camera_t *camera,
+                                          dc1394switch_t *on_off,
+                                          dc1394switch_t *show_area,
+                                          uint32_t       *left, 
+                                          uint32_t       *top,
+                                          uint32_t       *width,
+                                          uint32_t       *height)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_autofnc_aoi_t sAFAOI;
+
+    /* get register */
+    err=dc1394_get_adv_control_registers(camera,
+                                         REG_CAMERA_AVT_AUTOFNC_AOI, 
+                                         (uint32_t*) &sAFAOI, 
+                                         sizeof(dc1394_avt_csradv_autofnc_aoi_t)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT autofunction AOI Registers");
+
+    /* read config */
+    *on_off = (sAFAOI.m_Ctrl.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+    *show_area = (sAFAOI.m_Ctrl.m_bShowWorkArea!=0)? DC1394_ON : DC1394_OFF;
+    *left = sAFAOI.m_ImagePos.m_nLeft;
+    *top = sAFAOI.m_ImagePos.m_nTop;
+    *width = sAFAOI.m_ImageSize.m_nWidth;
+    *height = sAFAOI.m_ImageSize.m_nHeight;
+
+    return DC1394_SUCCESS;
+}
+
+
 /************************************************************************/
-/* Set Automatic white balance with Area Of Interest AOI                */
+/* Set Autofunction AOI - deprecated                                    */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_aoi(dc1394camera_t *camera,
@@ -1169,28 +2236,102 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Get test_images                                                        */
+/* Set Autofunction AOI                                                 */
 /************************************************************************/
-dc1394error_t
-dc1394_avt_get_test_images(dc1394camera_t *camera, uint32_t *image_no)
+dc1394error_t dc1394_avt_set_autofunc_aoi(dc1394camera_t *camera,
+                                          dc1394switch_t on_off,
+                                          dc1394switch_t show_area,
+                                          uint32_t       left, 
+                                          uint32_t       top,
+                                          uint32_t       width,
+                                          uint32_t       height)
 {
     dc1394error_t err;
-    uint32_t value;
+    dc1394_avt_csradv_autofnc_aoi_t sAFAOI;
 
-    /* Retrieve test image number */
-    err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_TEST_IMAGE, &value);
-    DC1394_ERR_RTN(err,"Could not get AVT test image");
+    /* get registers */
+    err=dc1394_get_adv_control_registers(camera,
+                                         REG_CAMERA_AVT_AUTOFNC_AOI, 
+                                         (uint32_t*) &sAFAOI, 
+                                         sizeof(dc1394_avt_csradv_autofnc_aoi_t)/4);
+    DC1394_ERR_RTN(err,"Could not get AVT Autofunction AOI Registers");
 
-    /* Numero Image : Bits 28..31 */
-    *image_no =(uint32_t)((value & 0xFUL));
+    /* set config */
+    sAFAOI.m_Ctrl.m_bOnOff = (on_off==DC1394_ON)? 1:0;
+    sAFAOI.m_Ctrl.m_bShowWorkArea = (show_area==DC1394_ON)? 1:0;
+    sAFAOI.m_ImagePos.m_nLeft = left;
+    sAFAOI.m_ImagePos.m_nTop = top;
+    sAFAOI.m_ImageSize.m_nWidth = width;
+    sAFAOI.m_ImageSize.m_nHeight = height;
+
+    /* write back registers */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             REG_CAMERA_AVT_AUTOFNC_AOI, 
+                                             (uint32_t*) &sAFAOI, 
+                                             sizeof(dc1394_avt_csradv_autofnc_aoi_t)/4);
+    DC1394_ERR_RTN(err,"Could not set AVT Autofunction AOI Registers");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get supported test_images                                            */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_get_test_images_info(dc1394camera_t *camera, 
+                                dc1394bool_t   *TestImage1,
+                                dc1394bool_t   *TestImage2,
+                                dc1394bool_t   *TestImage3,
+                                dc1394bool_t   *TestImage4,
+                                dc1394bool_t   *TestImage5,
+                                dc1394bool_t   *TestImage6,
+                                dc1394bool_t   *TestImage7)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_testpix_t sTestPix;
+
+    /* Retrieve test image number */
+    err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_TEST_IMAGE, (uint32_t*)  &sTestPix);
+    DC1394_ERR_RTN(err,"Could not get AVT test image");
+
+    /* read inquiries */
+    *TestImage1 = (sTestPix.m.m_bImg1Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage2 = (sTestPix.m.m_bImg2Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage3 = (sTestPix.m.m_bImg3Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage4 = (sTestPix.m.m_bImg4Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage5 = (sTestPix.m.m_bImg5Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage6 = (sTestPix.m.m_bImg6Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+    *TestImage7 = (sTestPix.m.m_bImg7Inq!=0)? DC1394_TRUE : DC1394_FALSE;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get test_images                                                      */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_get_test_images(dc1394camera_t *camera, uint32_t *image_no)
+{
+    dc1394error_t err;
+    uint32_t value;
+
+    /* Retrieve test image number */
+    err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_TEST_IMAGE, &value);
+    DC1394_ERR_RTN(err,"Could not get AVT test image");
+
+    /* Numero Image : Bits 28..31 */
+    *image_no =(uint32_t)((value & 0xFUL));
 
     return DC1394_SUCCESS;
 }
 
 
 /************************************************************************/
-/* Set test_images                                                        */
+/* Set test_images                                                      */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_test_images(dc1394camera_t *camera, uint32_t image_no)
@@ -1214,7 +2355,7 @@
 
 
 /************************************************************************/
-/* Get frame info                                                        */
+/* Get frame info - deprecated                                          */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_frame_info(dc1394camera_t *camera, uint32_t *framecounter)
@@ -1234,7 +2375,48 @@
 
 
 /************************************************************************/
-/* Reset frame info                                                        */
+/* Get frame counter                                                    */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_get_frame_counter(dc1394camera_t *camera, const dc1394_avt_smart_feature_info_t *feature_info, uint32_t *framecounter)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    /* get register offset */
+    uint64_t offset;
+    if( smart_feature_full->Internal.Inq1.m_bFrameInfo != 0 )
+    {
+        offset = REG_CAMERA_AVT_FRAMEINFO;
+    }
+    else if( smart_feature_full->Internal.Inq1.m_bFrmCounter2 != 0 )
+    {
+        offset = REG_CAMERA_AVT_FRAMEINFO_NEW;
+    }
+    else return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    /* get register */
+    dc1394_avt_csradv_frameinfo_t sFrameInfo;
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             offset, 
+                                             (uint32_t*) &sFrameInfo,
+                                             sizeof(dc1394_avt_csradv_frameinfo_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature FrameInfo");
+
+    /* get frame counter */
+    *framecounter = sFrameInfo.m_nFrameCounter;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Reset frame info - deprecated                                        */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_reset_frame_info(dc1394camera_t *camera)
@@ -1247,8 +2429,111 @@
     return DC1394_SUCCESS;
 }
 
+
+/************************************************************************/
+/* Reset frame counter                                                  */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_reset_frame_counter(dc1394camera_t                           *camera, 
+                               const dc1394_avt_smart_feature_info_t    *feature_info)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    /* get register offset */
+    uint64_t offset;
+    if( smart_feature_full->Internal.Inq1.m_bFrameInfo != 0 )
+    {
+        offset = REG_CAMERA_AVT_FRAMEINFO;
+    }
+    else if( smart_feature_full->Internal.Inq1.m_bFrmCounter2 != 0 )
+    {
+        offset = REG_CAMERA_AVT_FRAMEINFO_NEW;
+    }
+    else return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    /* get register */
+    dc1394_avt_csradv_frameinfo_t sFrameInfo;
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             offset, 
+                                             (uint32_t*) &sFrameInfo,
+                                             1 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature FrameInfo");
+
+    /* set reset flag */
+    sFrameInfo.m_Cmd.m_bClearFrameCounter = 1;
+
+    /* write register */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             offset, 
+                                             (uint32_t*) &sFrameInfo, 
+                                             1 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature FrameInfo");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get trigger counter                                                  */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_get_trigger_counter(dc1394camera_t *camera, uint32_t *triggercounter)
+{
+    dc1394error_t err;
+
+    /* get register */
+    dc1394_avt_csradv_frameinfo_t sTriggerInfo;
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_TRGCOUNTER_NEW, 
+                                             (uint32_t*) &sTriggerInfo,
+                                             sizeof(dc1394_avt_csradv_frameinfo_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature TriggerCounter");
+
+    /* get frame counter */
+    *triggercounter = sTriggerInfo.m_nFrameCounter;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Reset trigger counter                                                */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_reset_trigger_counter(dc1394camera_t *camera)
+{
+    dc1394error_t err;
+
+    /* get register */
+    dc1394_avt_csradv_frameinfo_t sTriggerInfo;
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_TRGCOUNTER_NEW, 
+                                             (uint32_t*) &sTriggerInfo,
+                                             1 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature TriggerCounter");
+
+    /* set reset flag */
+    sTriggerInfo.m_Cmd.m_bClearFrameCounter = 1;
+
+    /* write register */
+    err = dc1394_set_adv_control_registers ( camera,
+                                             REG_CAMERA_AVT_TRGCOUNTER_NEW, 
+                                             (uint32_t*) &sTriggerInfo, 
+                                             1 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature TriggerCounter");
+
+    return DC1394_SUCCESS;
+}
+
+
 /************************************************************************/
-/* Get Deferred image transport                                                */
+/* Get Deferred image transport                                         */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_deferred_trans(dc1394camera_t *camera,
@@ -1279,7 +2564,7 @@
 
 
 /************************************************************************/
-/* Set Deferred image transport                                                */
+/* Set Deferred image transport                                         */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_set_deferred_trans(dc1394camera_t *camera,
@@ -1317,9 +2602,8 @@
 }
 
 
-
 /************************************************************************/
-/* Get GPData info                                                        */
+/* Get GPData info                                                      */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_get_gpdata_info(dc1394camera_t *camera, uint32_t *BufferSize)
@@ -1338,142 +2622,125 @@
 
 
 /************************************************************************/
-/* Common code for GPData register access computation                        */
-/************************************************************************/
-static void gpdata_io_common(uint32_t *buf_local, uint32_t gpdata_numquads,
-                             uint32_t *nextIndex, uint32_t index, uint32_t size,
-                             uint32_t *newBufferSize, uint32_t *nQuadWriteSize,
-                             dc1394bool_t *finish)
-{
-    /* clear buffer */
-    memset(buf_local, 0, gpdata_numquads * sizeof(uint32_t));
-
-    /* calculate the index after writing the next block */
-    *nextIndex = index + (gpdata_numquads * 4);
-    /* if the next index lies behind the allocated memory -> align */
-    if (size < *nextIndex) {
-        *newBufferSize = (gpdata_numquads * 4) - (*nextIndex - size);
-        /* if the reduced write-buffer size (buffer-size - 'overhang') is dividable by 4 */
-        *nQuadWriteSize = *newBufferSize / 4;
-        if ((*newBufferSize % 4) != 0)
-            *nQuadWriteSize = *nQuadWriteSize + 1;
-
-        *finish = DC1394_TRUE; /* ...because it's the last block */
-    }
-    else
-        *nQuadWriteSize = gpdata_numquads;
-
-    if (*nextIndex == size)
-        *finish = DC1394_TRUE;
-}
-
-
-/************************************************************************/
-/* Read size number of bytes from GPData buffer                                */
+/* Read size number of bytes from GPData buffer                         */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_read_gpdata(dc1394camera_t *camera, unsigned char *buf, uint32_t size)
 {
-    uint32_t gpdata_numquads, gpdata_bufsize;
-    uint32_t nQuadReadSize, newBufferSize;
-    uint32_t i, index = 0, nextIndex;
-    uint32_t *buf_local;
-    dc1394bool_t finish = DC1394_FALSE;
-    dc1394error_t err;
-
-    /* determine gpdata_bufsize (as read-block-size) */
-    err = dc1394_avt_get_gpdata_info(camera, &gpdata_bufsize);
-    DC1394_ERR_RTN(err,"Could not get AVT GPData info");
-
-    /* calculate the number of quadlets in the gpdata buffer */
-    gpdata_numquads = gpdata_bufsize / 4;
-    if ((gpdata_bufsize % 4) != 0)
-        gpdata_numquads++;
-
-    /* allocate memory for the 'read-buffer' */
-    buf_local = malloc(gpdata_numquads * sizeof(uint32_t));
-    if (buf_local == NULL)
-        return DC1394_FAILURE;
-
-    do {
-        gpdata_io_common(buf_local, gpdata_numquads, &nextIndex, index, size, &newBufferSize, &nQuadReadSize, &finish);
-
-        /* read block */
-        err = dc1394_get_adv_control_registers(camera, REG_CAMERA_AVT_GPDATA_BUFFER,
-                                               buf_local, nQuadReadSize);
-        if (err != DC1394_SUCCESS) {
-            free(buf_local);
-            return DC1394_FAILURE;
-        }
+    dc1394error_t                               err;
+    uint32_t                                    GPDataSize;
+
+    err = dc1394_avt_get_gpdata_info(camera, &GPDataSize);
+    DC1394_ERR_RTN(err,"Could not get AVT GPData Info");
 
-        /* copy block-contents to user buf */
-        for (i = 0; i < nQuadReadSize; i++)
-            memcpy(buf + index + (i * 4), &buf_local[i], sizeof(uint32_t));
+    /* GP Data buffer size should be a multiple of four */
+    GPDataSize -= GPDataSize%4;
 
-        index += (nQuadReadSize * 4);
+    uint32_t nSize_WholeQuads = size - (size%4);
+    uint32_t nSize_Remainder = size%4;
+
+    uint32_t nDataRead = 0;
+    uint32_t nChunkSize;
+
+    while (nDataRead < nSize_WholeQuads)
+    {
+        // Compute count of data to read in this run.
+        nChunkSize = MIN (GPDataSize, nSize_WholeQuads - nDataRead);
+
+        // Read chunk from camera.
+        err = dc1394_get_adv_control_registers( camera,
+                                                REG_CAMERA_AVT_GPDATA_BUFFER,
+                                                ((uint32_t*) buf) + (nDataRead/4),
+                                                nChunkSize/4 );
+        DC1394_ERR_RTN(err,"Can't read GPData buffer!");
+
+        // Prepare to read next chunk.
+        nDataRead += nChunkSize;
+    }
 
-        /* loop until all bytes are read */
-    } while (!finish);
+    /* read remaining bytes when size is not a multiple of four */
+    if( nSize_Remainder>0 )
+    {
+        unsigned char quadbuf[4];
+        err = dc1394_get_adv_control_registers( camera,
+                                                REG_CAMERA_AVT_GPDATA_BUFFER,
+                                                (uint32_t*) quadbuf,
+                                                1 );
+        DC1394_ERR_RTN(err,"Can't write data buffer!");
+
+        buf[nDataRead] = quadbuf[0];
+        if( nSize_Remainder>1 )
+        {
+            buf[nDataRead+1] = quadbuf[1];
+        }
+        if( nSize_Remainder>2 )
+        {
+            buf[nDataRead+2] = quadbuf[2];
+        }
+    }
 
-    free(buf_local);
     return DC1394_SUCCESS;
 }
 
 
 /************************************************************************/
-/* Write size number of bytes to GPData buffer                                */
+/* Write size number of bytes to GPData buffer                          */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_write_gpdata(dc1394camera_t *camera, unsigned char *buf, uint32_t size)
 {
-    uint32_t gpdata_bufsize, gpdata_numquads;
-    uint32_t nQuadWriteSize, newBufferSize;
-    uint32_t i, index = 0, nextIndex;
-    uint32_t *buf_local;
-    dc1394bool_t finish = DC1394_FALSE;
-    dc1394error_t err;
-
-    /* determine gpdata_bufsize */
-    err = dc1394_avt_get_gpdata_info(camera, &gpdata_bufsize);
-    DC1394_ERR_RTN(err,"Could not get AVT GPData info");
-
-    /* calculate the number of quadlets in the gpdata buffer */
-    gpdata_numquads = gpdata_bufsize / 4;
-    if ((gpdata_bufsize % 4) != 0)
-        gpdata_numquads++;
-
-    /* allocate memory for the write buffer */
-    buf_local = malloc(gpdata_numquads * sizeof(uint32_t));
-    if (buf_local == NULL)
-        return DC1394_FAILURE;
-
-    do {
-        gpdata_io_common(buf_local, gpdata_numquads, &nextIndex, index, size, &newBufferSize, &nQuadWriteSize, &finish);
-
-        /* copy block-contents to buf_local */
-        for (i = 0; i < nQuadWriteSize; i++)
-            memcpy(&buf_local[i], buf + index + (i * 4), sizeof(uint32_t));
-
-        /* write block */
-        err = dc1394_set_adv_control_registers(camera, REG_CAMERA_AVT_GPDATA_BUFFER,
-                                               buf_local, nQuadWriteSize);
-        if (err != DC1394_SUCCESS) {
-            free(buf_local);
-            return DC1394_FAILURE;
-        }
+    dc1394error_t                               err;
+    uint32_t                                    GPDataSize;
+
+    err = dc1394_avt_get_gpdata_info(camera, &GPDataSize);
+    DC1394_ERR_RTN(err,"Could not get AVT GPData Info");
 
-        index += (nQuadWriteSize * 4);
+    /* GP Data buffer size should be a multiple of four */
+    GPDataSize -= GPDataSize%4;
 
-        /* loop until all bytes are read */
-    } while (!finish);
+    uint32_t nSize_WholeQuads = size - (size%4);
+    uint32_t nSize_Remainder = size%4;
+
+    uint32_t nDataWritten = 0;
+    uint32_t nChunkSize;
+
+    while (nDataWritten < nSize_WholeQuads)
+    {
+        // Compute count of data to write in this run.
+        nChunkSize = MIN (GPDataSize, nSize_WholeQuads - nDataWritten);
+
+        // Write chunk to camera.
+        err = dc1394_set_adv_control_registers( camera,
+                                                REG_CAMERA_AVT_GPDATA_BUFFER,
+                                                ((uint32_t*) buf) + (nDataWritten/4),
+                                                nChunkSize/4 );
+        DC1394_ERR_RTN(err,"Can't write data buffer!");
+
+        // Prepare to read next chunk.
+        nDataWritten += nChunkSize;
+    }
+
+    /* write remaining bytes when size is not a multiple of four */
+    if( nSize_Remainder>0 )
+    {
+        unsigned char quadbuf[4];
+        quadbuf[0] = buf[nDataWritten];
+        quadbuf[1] = (nSize_Remainder>1)? buf[nDataWritten+1] : 0;
+        quadbuf[2] = (nSize_Remainder>2)? buf[nDataWritten+2] : 0;
+        quadbuf[3] = 0;
+        err = dc1394_set_adv_control_registers( camera,
+                                                REG_CAMERA_AVT_GPDATA_BUFFER,
+                                                (uint32_t*) quadbuf,
+                                                1 );
+        DC1394_ERR_RTN(err,"Can't write data buffer!");
+    }
 
-    free(buf_local);
     return DC1394_SUCCESS;
 }
 
 
 /************************************************************************/
-/* Read shading image from camera into buffer                               */
+/* Read shading image from camera into buffer                           */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_read_shading_img(dc1394camera_t *camera, unsigned char *buf,
@@ -1504,20 +2771,16 @@
 
 
 /************************************************************************/
-/* Write shading image from buffer to camera                                */
+/* Write shading image from buffer to camera                            */
 /************************************************************************/
 dc1394error_t
 dc1394_avt_write_shading_img(dc1394camera_t *camera, unsigned char *buf,
                              uint32_t size)
 {
     dc1394error_t err;
-    dc1394bool_t en_read;
-    uint32_t addr;
 
     /* Enable write at address 0 */
-    err = dc1394_avt_get_shading_mem_ctrl(camera, NULL, &en_read, NULL);
-    DC1394_ERR_RTN(err,"Could not read AVT shading mem ctrl");
-    err = dc1394_avt_set_shading_mem_ctrl(camera, DC1394_TRUE, en_read, 0);
+    err = dc1394_avt_set_shading_mem_ctrl(camera, DC1394_TRUE, DC1394_FALSE, 0);
     DC1394_ERR_RTN(err,"Could not write AVT shading mem ctrl");
 
     /* Write data */
@@ -1525,16 +2788,40 @@
     DC1394_ERR_RTN(err,"Could not write AVT gpdata");
 
     /* Disable write */
-    err = dc1394_avt_get_shading_mem_ctrl(camera, NULL, &en_read, &addr);
-    DC1394_ERR_RTN(err,"Could not read AVT shading mem ctrl");
-    err = dc1394_avt_set_shading_mem_ctrl(camera, DC1394_FALSE, en_read, addr);
+    err = dc1394_avt_set_shading_mem_ctrl(camera, DC1394_FALSE, DC1394_FALSE, 0);
     DC1394_ERR_RTN(err,"Could not write AVT shading mem ctrl");
 
     return DC1394_SUCCESS;
 }
 
+
+/************************************************************************/
+/* Write lookup table from buffer to camera                             */
+/************************************************************************/
+dc1394error_t
+dc1394_avt_write_lut(dc1394camera_t *camera, uint32_t LutNo, unsigned char *buf,
+                     uint32_t size)
+{
+    dc1394error_t err;
+
+    /* Enable write at address 0 */
+    err = dc1394_avt_set_lut_mem_ctrl(camera, DC1394_TRUE, LutNo, 0);
+    DC1394_ERR_RTN(err,"Could not write AVT LUT mem ctrl");
+
+    /* Write data */
+    err = dc1394_avt_write_gpdata(camera, buf, size);
+    DC1394_ERR_RTN(err,"Could not write AVT gpdata");
+
+    /* Disable write */
+    err = dc1394_avt_set_lut_mem_ctrl(camera, DC1394_FALSE, LutNo, 0);
+    DC1394_ERR_RTN(err,"Could not write AVT LUT mem ctrl");
+
+    return DC1394_SUCCESS;
+}
+
+
 /************************************************************************/
-/* Read channel adjust (AVT Pike)                                           */
+/* Read channel adjust gain (AVT Pike)                                  */
 /************************************************************************/
 dc1394error_t dc1394_avt_get_channel_adjust(dc1394camera_t *camera, int16_t *channel_adjust)
 {
@@ -1543,7 +2830,7 @@
 
     /* Retrieve current channel adjust */
     err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_CHANNEL_ADJUST_VALUE, &value);
-    DC1394_ERR_RTN(err,"Could not get AVT channel adjust");
+    DC1394_ERR_RTN(err,"Could not get AVT channel gain adjust");
 
     /* channel adjust: Bits 16..31 */
     *channel_adjust = (int16_t)value;
@@ -1551,8 +2838,9 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Write channel adjust (AVT Pike)                                           */
+/* Write channel adjust gain (AVT Pike)                                 */
 /************************************************************************/
 dc1394error_t dc1394_avt_set_channel_adjust(dc1394camera_t *camera, int16_t channel_adjust)
 {
@@ -1560,15 +2848,51 @@
 
     /* Set new channel adjust */
     err=dc1394_set_adv_control_register(camera,REG_CAMERA_AVT_CHANNEL_ADJUST_VALUE, (uint32_t)channel_adjust);
-    DC1394_ERR_RTN(err,"Could not set AVT channel adjust");
+    DC1394_ERR_RTN(err,"Could not set AVT channel gain adjust");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Read channel adjust offset (AVT Pike)                                */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_channel_adjust_offset(dc1394camera_t *camera,
+                                            int16_t *channel_adjust)
+{
+    dc1394error_t err;
+    uint32_t value;
+
+    /* Retrieve current channel adjust */
+    err=dc1394_get_adv_control_register(camera,REG_CAMERA_AVT_CHANNEL_ADJUST_OFFSET_VALUE, &value);
+    DC1394_ERR_RTN(err,"Could not get AVT channel offset adjust");
+
+    /* channel adjust: Bits 16..31 */
+    *channel_adjust = (int16_t)value;
 
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Set Color Correction + Coefficients                                          */
+/* Write channel adjust offset (AVT Pike)                               */
 /************************************************************************/
+dc1394error_t dc1394_avt_set_channel_adjust_offset(dc1394camera_t *camera,
+                                            int16_t channel_adjust)
+{
+    dc1394error_t err;
+
+    /* Set new channel adjust */
+    err=dc1394_set_adv_control_register(camera,REG_CAMERA_AVT_CHANNEL_ADJUST_OFFSET_VALUE, (uint32_t)channel_adjust);
+    DC1394_ERR_RTN(err,"Could not set AVT channel offset adjust");
 
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Color Correction + Coefficients                                  */
+/************************************************************************/
 dc1394error_t dc1394_avt_set_color_corr(dc1394camera_t *camera, dc1394bool_t on_off, dc1394bool_t reset, int32_t Crr, int32_t Cgr, int32_t Cbr, int32_t Crg, int32_t Cgg, int32_t Cbg, int32_t Crb, int32_t Cgb, int32_t Cbb)
 {
     dc1394error_t err;
@@ -1625,9 +2949,8 @@
 
 
 /************************************************************************/
-/* Get Color Correction + Coefficients                                            */
+/* Get Color Correction + Coefficients                                  */
 /************************************************************************/
-
 dc1394error_t dc1394_avt_get_color_corr(dc1394camera_t *camera, dc1394bool_t *on_off, int32_t *Crr, int32_t *Cgr, int32_t *Cbr, int32_t *Crg, int32_t *Cgg, int32_t *Cbg, int32_t *Crb, int32_t *Cgb, int32_t *Cbb)
 {
     dc1394error_t err;
@@ -1673,10 +2996,10 @@
     return DC1394_SUCCESS;
 }
 
+
 /************************************************************************/
-/* Get HSNR                                                                   */
+/* Get HSNR                                                             */
 /************************************************************************/
-
 dc1394error_t dc1394_avt_get_hsnr(dc1394camera_t *camera, dc1394bool_t *on_off, uint32_t *grabCount)
 {
     dc1394error_t err;
@@ -1697,9 +3020,8 @@
 
 
 /************************************************************************/
-/* Set HSNR                                                                      */
+/* Set HSNR                                                             */
 /************************************************************************/
-
 dc1394error_t dc1394_avt_set_hsnr(dc1394camera_t *camera, dc1394bool_t on_off, uint32_t grabCount)
 {
     dc1394error_t err;
@@ -1721,3 +3043,919 @@
 
     return DC1394_SUCCESS;
 }
+
+
+/************************************************************************/
+/* Get SIS                                                              */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_sis(dc1394camera_t                        *camera, 
+                                 const dc1394_avt_smart_feature_info_t *feature_info, 
+                                 dc1394switch_t                        *on_off, 
+                                 int16_t                               *linePos,
+                                 uint32_t                              *userVal)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    uint64_t offset;
+    /*
+    if( smart_feature_full->Internal.Inq1.m_bFrameInfo != 0 )
+    {
+        offset = REG_CAMERA_AVT_TIMESTAMP;
+    }
+    else*/ if( smart_feature_full->Internal.Inq1.m_bTimestamp2 != 0 )
+    {
+        offset = REG_CAMERA_AVT_TIMESTAMP_NEW;
+    }
+    else if( smart_feature_full->Internal.Inq3.m_bSIS != 0 )
+    {
+        offset = REG_CAMERA_AVT_SIS;
+    }
+    else
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    switch(offset)
+    {
+        case REG_CAMERA_AVT_TIMESTAMP:
+        case REG_CAMERA_AVT_TIMESTAMP_NEW:
+            {
+                dc1394_avt_csradv_imagestamp_t sImageStamp;
+                err = dc1394_get_adv_control_registers ( camera, 
+                                                         offset, 
+                                                         (uint32_t*) &sImageStamp,
+                                                         sizeof(dc1394_avt_csradv_imagestamp_t)/4 );
+                DC1394_ERR_RTN(err,"Could not get AVT advanced feature TimeStamp/SIS");
+
+                *on_off = ( sImageStamp.m_Ctrl.m.m_bOnOff != 0 ) ? DC1394_ON : DC1394_OFF;
+                *linePos = (int16_t) sImageStamp.m_Ctrl.m.m_nLinePos;
+                break;
+            }
+        case REG_CAMERA_AVT_SIS:
+        default:
+            {
+                dc1394_avt_csradv_sis_t sSIS;
+                err = dc1394_get_adv_control_registers ( camera, 
+                                                         offset, 
+                                                         (uint32_t*) &sSIS,
+                                                         sizeof(dc1394_avt_csradv_sis_t)/4 );
+                DC1394_ERR_RTN(err,"Could not get AVT advanced feature TimeStamp/SIS");
+
+                *on_off = ( sSIS.m_Ctrl.m.m_bOnOff != 0 ) ? DC1394_ON : DC1394_OFF;
+                *linePos = (int16_t) sSIS.m_Ctrl.m.m_nLineNo;
+                if(NULL!=userVal)
+                {
+                    *userVal = sSIS.m_nUserVal;
+                }
+                break;
+            }
+    }
+    return err;
+}
+
+
+/************************************************************************/
+/* Set SIS                                                              */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_sis(dc1394camera_t                         *camera, 
+                                 const dc1394_avt_smart_feature_info_t  *feature_info, 
+                                 dc1394switch_t                         on_off, 
+                                 int16_t                                linePos,
+                                 uint32_t                               userVal)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    uint64_t offset;
+    /*if( smart_feature_full->Internal.Inq1.m_bTimestamp != 0 )
+    {
+        offset = REG_CAMERA_AVT_TIMESTAMP;
+    }
+    else*/ if( smart_feature_full->Internal.Inq1.m_bTimestamp2 != 0 )
+    {
+        offset = REG_CAMERA_AVT_TIMESTAMP_NEW;
+    }
+    else if( smart_feature_full->Internal.Inq3.m_bSIS != 0 )
+    {
+        offset = REG_CAMERA_AVT_SIS;
+    }
+    else
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    switch(offset)
+    {
+        case REG_CAMERA_AVT_TIMESTAMP:
+        case REG_CAMERA_AVT_TIMESTAMP_NEW:
+            {
+                dc1394_avt_csradv_imagestamp_t sImageStamp;
+                err = dc1394_get_adv_control_registers ( camera, 
+                                                         offset, 
+                                                         (uint32_t*) &sImageStamp,
+                                                         sizeof(dc1394_avt_csradv_imagestamp_t)/4 );
+                DC1394_ERR_RTN(err,"Could not get AVT advanced feature TimeStamp/SIS");
+
+                sImageStamp.m_Ctrl.m.m_bOnOff = ( on_off == DC1394_ON )? 1 : 0;
+                sImageStamp.m_Ctrl.m.m_nLinePos = (uint32_t) linePos;
+
+                err = dc1394_set_adv_control_registers ( camera,
+                                                         offset, 
+                                                         (uint32_t*) &sImageStamp, 
+                                                         sizeof(dc1394_avt_csradv_imagestamp_t)/4 );
+                DC1394_ERR_RTN(err,"Could not set AVT advanced feature TimeStamp/SIS");
+
+                break;
+            }
+        case REG_CAMERA_AVT_SIS:
+        default:
+            {
+                dc1394_avt_csradv_sis_t sSIS;
+                err = dc1394_get_adv_control_registers ( camera, 
+                                                         offset, 
+                                                         (uint32_t*) &sSIS,
+                                                         sizeof(dc1394_avt_csradv_sis_t)/4 );
+                DC1394_ERR_RTN(err,"Could not get AVT advanced feature TimeStamp/SIS");
+
+                sSIS.m_Ctrl.m.m_bOnOff = ( on_off == DC1394_ON )? 1 : 0;
+                sSIS.m_Ctrl.m.m_nLineNo = (uint32_t) linePos;
+                sSIS.m_nUserVal = userVal;
+
+                err = dc1394_set_adv_control_registers ( camera,
+                                                         offset, 
+                                                         (uint32_t*) &sSIS, 
+                                                         sizeof(dc1394_avt_csradv_sis_t)/4 );
+                DC1394_ERR_RTN(err,"Could not set AVT advanced feature TimeStamp/SIS");
+
+                break;
+            }
+    }
+    return err;
+}
+
+
+/************************************************************************/
+/* Get SIS data inquiry                                                 */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_sis_data_inquiry(const dc1394_avt_smart_feature_info_t *feature_info, 
+                                              dc1394_avt_sis_data                   *sis_data_inquiry )
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    memset(sis_data_inquiry, 0, sizeof(dc1394_avt_sis_data));
+
+    /*if( smart_feature_full->Internal.Inq1.m_bTimestamp != 0 )
+    {
+        sis_data_inquiry->m_CycleTime = 1;
+    }
+    else*/ if( smart_feature_full->Internal.Inq1.m_bTimestamp2 != 0 )
+    {
+        sis_data_inquiry->CycleTime.m.Offset = 1;
+        sis_data_inquiry->CycleTime.m.Cycles = 1;
+        sis_data_inquiry->CycleTime.m.Seconds = 1;
+        sis_data_inquiry->FrameCounter = 1;
+        sis_data_inquiry->TriggerCounter = 1;
+    }
+    else if( smart_feature_full->Internal.Inq3.m_bSIS != 0 )
+    {
+        sis_data_inquiry->CycleTime.m.Offset = 1;
+        sis_data_inquiry->CycleTime.m.Cycles = 1;
+        sis_data_inquiry->CycleTime.m.Seconds = 1;
+        sis_data_inquiry->FrameCounter = 1;
+        sis_data_inquiry->TriggerCounter = 1;
+        sis_data_inquiry->AOILeft = 1;
+        sis_data_inquiry->AOITop = 1;
+        sis_data_inquiry->AOIWidth = 1;
+        sis_data_inquiry->AOIHeight = 1;
+        sis_data_inquiry->Shutter = 1;
+        sis_data_inquiry->Gain = 1;
+        if( smart_feature_full->Internal.Inq2.m_bOutp_1 != 0 )
+            sis_data_inquiry->OutputState[0] = 1;
+        if( smart_feature_full->Internal.Inq2.m_bOutp_2 != 0 )
+            sis_data_inquiry->OutputState[1] = 1;
+        if( smart_feature_full->Internal.Inq2.m_bOutp_3 != 0 )
+            sis_data_inquiry->OutputState[2] = 1;
+        if( smart_feature_full->Internal.Inq2.m_bOutp_4 != 0 )
+            sis_data_inquiry->OutputState[3] = 1;
+        if( smart_feature_full->Internal.Inq2.m_bInp_1 != 0 )
+            sis_data_inquiry->InputState[0] = 1;
+        if( smart_feature_full->Internal.Inq2.m_bInp_2 != 0 )
+            sis_data_inquiry->InputState[1] = 1;
+        sis_data_inquiry->SequenceIndex = 1;
+        sis_data_inquiry->ColorCoding = 1;
+        sis_data_inquiry->SerialNumber = 1;
+        sis_data_inquiry->UserValue = 1;
+    }
+    else
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get SIS data                                                         */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_sis_data(const dc1394_avt_smart_feature_info_t *feature_info,
+                                      dc1394video_frame_t                   *frame,
+                                      int16_t                               linePos,
+                                      dc1394_avt_sis_data                   *sis_data)
+{
+    if(SIZE_AVT_SMART_FEATURE_STRUCT_V1>feature_info->Size)
+    {
+        return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    dc1394error_t err;
+    dc1394_avt_smart_feature_info_full_t* smart_feature_full = (dc1394_avt_smart_feature_info_full_t*) feature_info;
+
+    int sisline = (int) MIN( linePos, linePos + (int16_t) frame->size[1] );
+    
+    uint32_t bitsPerPixel;
+    err = dc1394_get_color_coding_bit_size( frame->color_coding, &bitsPerPixel );
+    DC1394_ERR_RTN(err,"Could not get color coding bit size");
+
+    unsigned char * sisImageData = frame->image + (sisline*frame->size[0]*bitsPerPixel/8);
+    /*if( smart_feature_full->Internal.Inq1.m_bTimestamp != 0 )
+    {
+        sis_data->m_CycleTime = ((uint32_t*) sisImageData)[0];
+    }
+    else*/ if( smart_feature_full->Internal.Inq1.m_bTimestamp2 != 0 )
+    {
+        uint32_t cycleTime_dev = ((uint32_t*) sisImageData)[0];
+        sis_data->CycleTime.m_all = (cycleTime_dev&0xff)<<24 | (cycleTime_dev&0xff00)<<8 |
+                                    (cycleTime_dev&0xff0000)>>8 | (cycleTime_dev&0xff000000)>>24;
+        uint32_t frameCounter_dev = ((uint32_t*) sisImageData)[1];
+        sis_data->FrameCounter = (frameCounter_dev&0xff)<<24 | (frameCounter_dev&0xff00)<<8 |
+                                 (frameCounter_dev&0xff0000)>>8 | (frameCounter_dev&0xff000000)>>24;
+        uint32_t triggerCounter_dev = ((uint32_t*) sisImageData)[2];
+        sis_data->TriggerCounter = (triggerCounter_dev&0xff)<<24 | (triggerCounter_dev&0xff00)<<8 |
+                                   (triggerCounter_dev&0xff0000)>>8 | (triggerCounter_dev&0xff000000)>>24;
+    }
+    else if( smart_feature_full->Internal.Inq3.m_bSIS != 0 )
+    {
+        memcpy( sis_data, sisImageData, sizeof( dc1394_avt_sis_data ) );
+    }
+    else
+        return DC1394_FUNCTION_NOT_SUPPORTED;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get max iso size                                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_max_iso_size(dc1394camera_t *camera,
+                                          uint32_t       speed_mode,
+                                          dc1394switch_t *on_off,
+                                          uint32_t       *max_size)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_max_isosize_t sMaxIso;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_MAX_ISO_SIZE, 
+                                             (uint32_t*) &sMaxIso,
+                                             sizeof(dc1394_avt_csradv_max_isosize_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Max Iso Size");
+
+    /* read config */
+    switch( speed_mode )
+    {
+        case 2:
+            *on_off = (sMaxIso.m_S400.m.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+            *max_size = sMaxIso.m_S400.m.m_nMaxSize;
+            break;
+        case 3:
+            *on_off = (sMaxIso.m_S800.m.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+            *max_size = sMaxIso.m_S800.m.m_nMaxSize;
+            break;
+        case 4:
+            *on_off = (sMaxIso.m_S1600.m.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+            *max_size = sMaxIso.m_S1600.m.m_nMaxSize;
+            break;
+        case 5:
+            *on_off = (sMaxIso.m_S3200.m.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+            *max_size = sMaxIso.m_S3200.m.m_nMaxSize;
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set max iso size                                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_max_iso_size(dc1394camera_t *camera,
+                                          uint32_t       speed_mode,
+                                          dc1394switch_t on_off,
+                                          dc1394switch_t set_to_max,
+                                          uint32_t       max_size)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_max_isosize_t sMaxIso;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_MAX_ISO_SIZE, 
+                                             (uint32_t*) &sMaxIso,
+                                             sizeof(dc1394_avt_csradv_max_isosize_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Max Iso Size");
+
+    /* set config */
+    switch( speed_mode )
+    {
+        case 2:
+            sMaxIso.m_S400.m.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+            sMaxIso.m_S400.m.m_nMaxSize = max_size;
+            sMaxIso.m_S400.m.m_bSet2Max = (set_to_max==DC1394_ON)? 1 : 0;
+            break;
+        case 3:
+            sMaxIso.m_S800.m.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+            sMaxIso.m_S800.m.m_nMaxSize = max_size;
+            sMaxIso.m_S800.m.m_bSet2Max = (set_to_max==DC1394_ON)? 1 : 0;
+            break;
+        case 4:
+            sMaxIso.m_S1600.m.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+            sMaxIso.m_S1600.m.m_nMaxSize = max_size;
+            sMaxIso.m_S1600.m.m_bSet2Max = (set_to_max==DC1394_ON)? 1 : 0;
+            break;
+        case 5:
+            sMaxIso.m_S3200.m.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+            sMaxIso.m_S3200.m.m_nMaxSize = max_size;
+            sMaxIso.m_S3200.m.m_bSet2Max = (set_to_max==DC1394_ON)? 1 : 0;
+            break;
+        default:
+            return DC1394_INVALID_ARGUMENT_VALUE;
+    }
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_MAX_ISO_SIZE, 
+                                             (uint32_t*) &sMaxIso,
+                                             sizeof(dc1394_avt_csradv_max_isosize_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Max Iso Size");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Parameter Update Timing                                          */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_param_upd_timing(dc1394camera_t *camera,
+                                              uint32_t       *update_timing_mode)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_paramupd_timing_t sParamUpdTiming;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_PARAMUPD_MODE, 
+                                             (uint32_t*) &sParamUpdTiming,
+                                             sizeof(dc1394_avt_csradv_paramupd_timing_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Parameter Update Timing");
+
+    /* read config */
+    *update_timing_mode = sParamUpdTiming.m.m_nFpgaUpdMode;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Parameter Update Timing                                          */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_param_upd_timing(dc1394camera_t *camera,
+                                              uint32_t       update_timing_mode)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_paramupd_timing_t sParamUpdTiming;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_PARAMUPD_MODE, 
+                                             (uint32_t*) &sParamUpdTiming,
+                                             sizeof(dc1394_avt_csradv_paramupd_timing_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Parameter Update Timing");
+
+    /* set config */
+    sParamUpdTiming.m.m_nFpgaUpdMode = update_timing_mode;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_PARAMUPD_MODE, 
+                                             (uint32_t*) &sParamUpdTiming,
+                                             sizeof(dc1394_avt_csradv_paramupd_timing_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Parameter Update Timing");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Low Smear                                                        */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_low_smear(dc1394camera_t *camera,
+                                       dc1394switch_t *on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_low_smear_t sLowSmear;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_SMEAR, 
+                                             (uint32_t*) &sLowSmear,
+                                             sizeof(dc1394_avt_csradv_low_smear_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Low Smear");
+
+    /* read config */
+    *on_off = (sLowSmear.m_Ctrl.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Low Smear                                                        */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_low_smear(dc1394camera_t *camera,
+                                       dc1394switch_t on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_low_smear_t sLowSmear;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_SMEAR, 
+                                             (uint32_t*) &sLowSmear,
+                                             sizeof(dc1394_avt_csradv_low_smear_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Low Smear");
+
+    /* set config */
+    sLowSmear.m_Ctrl.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_SMEAR, 
+                                             (uint32_t*) &sLowSmear,
+                                             sizeof(dc1394_avt_csradv_low_smear_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Low Smear");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Low Noise Binning                                                */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_low_noise_binning(dc1394camera_t *camera,
+                                               dc1394switch_t *on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_global_res_rel_shutter_t sLowNoiseBinning; // global res rel shutter has same reg layout
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_NOISE_BINNING, 
+                                             (uint32_t*) &sLowNoiseBinning,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Low Noise Binning");
+
+    /* read config */
+    *on_off = (sLowNoiseBinning.m_Ctrl.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Low Noise Binning                                                */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_low_noise_binning(dc1394camera_t *camera,
+                                               dc1394switch_t on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_global_res_rel_shutter_t sLowNoiseBinning; // global res rel shutter has same reg layout
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_NOISE_BINNING, 
+                                             (uint32_t*) &sLowNoiseBinning,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Low Noise Binning");
+
+    /* set config */
+    sLowNoiseBinning.m_Ctrl.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_LOW_NOISE_BINNING, 
+                                             (uint32_t*) &sLowNoiseBinning,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Low Noise Binning");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Global Reset Release Shutter                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_global_res_rel_shutter(dc1394camera_t *camera,
+                                                    dc1394switch_t *on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_global_res_rel_shutter_t sGlobalRRShutter;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_GLOBAL_RESET_RELEASE_SHUTTER, 
+                                             (uint32_t*) &sGlobalRRShutter,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Global Reset Release Shutter");
+
+    /* read config */
+    *on_off = (sGlobalRRShutter.m_Ctrl.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Global Reset Release Shutter                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_global_res_rel_shutter(dc1394camera_t *camera,
+                                                    dc1394switch_t on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_global_res_rel_shutter_t sGlobalRRShutter;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_GLOBAL_RESET_RELEASE_SHUTTER, 
+                                             (uint32_t*) &sGlobalRRShutter,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Global Reset Release Shutter");
+
+    /* set config */
+    sGlobalRRShutter.m_Ctrl.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_GLOBAL_RESET_RELEASE_SHUTTER, 
+                                             (uint32_t*) &sGlobalRRShutter,
+                                             sizeof(dc1394_avt_csradv_global_res_rel_shutter_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Global Reset Release Shutter");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get User Profile                                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_user_profile(dc1394camera_t *camera,
+                                          uint32_t       *profile_id,
+                                          dc1394bool_t   *error,
+                                          uint32_t       *err_code )
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_userprofile_t sProfile;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_USER_PROFILE, 
+                                             (uint32_t*) &sProfile,
+                                             sizeof(dc1394_avt_csradv_userprofile_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature User Profile");
+
+    /* read config */
+    *profile_id = sProfile.m.m_nProfileID;
+    *error = (sProfile.m.m_bError!=0)? DC1394_ON : DC1394_OFF;
+    *err_code = sProfile.m.m_nErrCode;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set User Profile                                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_user_profile(dc1394camera_t *camera,
+                                          uint32_t       profile_id,
+                                          dc1394switch_t load_profile,
+                                          dc1394switch_t save_profile,
+                                          dc1394switch_t set_default )
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_userprofile_t sProfile;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_USER_PROFILE, 
+                                             (uint32_t*) &sProfile,
+                                             sizeof(dc1394_avt_csradv_userprofile_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature User Profile");
+
+    /* set config */
+    sProfile.m.m_nProfileID = profile_id;
+    sProfile.m.m_bSetAsDef = (set_default==DC1394_ON)? 1 : 0;
+    sProfile.m.m_bMemLoad = (load_profile==DC1394_ON)? 1 : 0;
+    sProfile.m.m_bMemSave = (save_profile==DC1394_ON)? 1 : 0;
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_USER_PROFILE, 
+                                             (uint32_t*) &sProfile,
+                                             sizeof(dc1394_avt_csradv_userprofile_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature User Profile");
+
+    /* poll camera until busy flag is cleared */
+    do
+    {
+        usleep( 50000 );
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_USER_PROFILE, 
+                                                 (uint32_t*) &sProfile,
+                                                 sizeof(dc1394_avt_csradv_userprofile_t)/4 );
+        DC1394_ERR_RTN(err,"Could not get AVT advanced feature User Profile");
+    }while( sProfile.m.m_bBusy!= 0 );
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get LED                                                              */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_led(dc1394camera_t *camera,
+                                 dc1394switch_t *on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_swfeature_t sSWFeature;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_SWFEATURE, 
+                                             (uint32_t*) &sSWFeature,
+                                             sizeof(dc1394_avt_csradv_swfeature_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature SW Feature");
+
+    /* read config */
+    *on_off = (sSWFeature.m.m_bBlankLED!=0)? DC1394_OFF : DC1394_ON; // value is inverted! enable led <> disable led
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set LED                                                              */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_led(dc1394camera_t *camera,
+                                 dc1394switch_t on_off)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_swfeature_t sSWFeature;
+
+    /* get register */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_SWFEATURE, 
+                                             (uint32_t*) &sSWFeature,
+                                             sizeof(dc1394_avt_csradv_swfeature_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature SW Feature");
+
+    /* set config */
+    sSWFeature.m.m_bBlankLED = (on_off==DC1394_ON)? 0 : 1; // value is inverted! enable led <> disable led
+
+    /* write back register */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_SWFEATURE, 
+                                             (uint32_t*) &sSWFeature,
+                                             sizeof(dc1394_avt_csradv_swfeature_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature SW Feature");
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Defect Pixel Correction Info                                     */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_dpc_info(dc1394camera_t *camera,
+                                      uint32_t       *MinThreshold,
+                                      uint32_t       *MaxThreshold,
+                                      uint32_t       *MaxSize)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_defect_pixel_correction_t sDPC;
+
+    /* get registers */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+
+    *MinThreshold = sDPC.m_Info.m_nMinThreshold;
+    *MaxThreshold = sDPC.m_Info.m_nMaxThreshold;
+    *MaxSize = sDPC.m_Info.m_nMaxSize;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Get Defect Pixel Correction                                          */
+/************************************************************************/
+dc1394error_t dc1394_avt_get_dpc(dc1394camera_t *camera,
+                                 dc1394switch_t *on_off,
+                                 uint32_t       *threshold,
+                                 uint32_t       *mean_value,
+                                 uint32_t       *data_size)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_defect_pixel_correction_t sDPC;
+
+    /* get registers */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+
+    /* read status */
+    *on_off = (sDPC.m_Ctrl.m_bOnOff!=0)? DC1394_ON : DC1394_OFF;
+    *threshold = sDPC.m_Ctrl.m_nThreshold;
+    *mean_value = sDPC.m_Ctrl.m_nMean;
+    *data_size = sDPC.m_Mem.m_nDPDataSize;
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Set Defect Pixel Correction                                          */
+/************************************************************************/
+dc1394error_t dc1394_avt_set_dpc(dc1394camera_t *camera,
+                                 dc1394switch_t on_off,
+                                 dc1394switch_t build_data,
+                                 dc1394switch_t zero_data,
+                                 dc1394switch_t mem_save,
+                                 dc1394switch_t mem_load,
+                                 uint32_t       threshold)
+{
+    dc1394error_t err;
+    dc1394_avt_csradv_defect_pixel_correction_t sDPC;
+
+    /* get registers */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+
+    /* read status */
+    sDPC.m_Ctrl.m_bOnOff = (on_off==DC1394_ON)? 1 : 0;
+    sDPC.m_Ctrl.m_bZeroDPData = (zero_data==DC1394_ON)? 1 : 0;
+    sDPC.m_Ctrl.m_bMemLoad = (mem_load==DC1394_ON)? 1 : 0;
+    sDPC.m_Ctrl.m_bMemSave = (mem_save==DC1394_ON)? 1 : 0;
+    sDPC.m_Ctrl.m_bBuildDPData = (build_data==DC1394_ON)? 1 : 0;
+    sDPC.m_Ctrl.m_nThreshold = threshold;
+
+    /* write back registers */
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Defect Pixel Correction");
+
+    /* Poll register until busy is cleared */
+    do
+    {
+        usleep(50000);
+        err = dc1394_get_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_DPC_CONTROL, 
+                                                 (uint32_t*) &sDPC,
+                                                 1 );
+        DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+    } while( sDPC.m_Ctrl.m_bBusy != 0 );
+
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Read Defect Pixel Correction Data                                    */
+/************************************************************************/
+dc1394error_t dc1394_avt_read_dpc_data(dc1394camera_t                *camera,
+                                       dc1394_avt_dpc_pixel_position *DestBuffer,
+                                       uint32_t                      *PixelCount,
+                                       uint32_t                      BufferSize )
+{
+    dc1394error_t                               err;
+    dc1394_avt_csradv_defect_pixel_correction_t sDPC;
+
+    /* get registers */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC.m_Ctrl,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+
+    /* Get amount of data to load */
+    uint32_t nDpcDataSize = sDPC.m_Mem.m_nDPDataSize;
+    /* DPDataSize indicates size in bytes, so it should be a multiple of 4 */
+    nDpcDataSize -= nDpcDataSize%4;
+
+    /* make sure not to write beyond the user buffer */
+    nDpcDataSize = MIN( nDpcDataSize, BufferSize*4 );
+
+    if (nDpcDataSize != 0)
+    {
+        // Enable read access.
+        sDPC.m_Mem.m_bEnaMemRD = 1;
+        sDPC.m_Mem.m_bEnaMemWR = 0;
+        sDPC.m_Mem.m_nAddrOffset = 0;
+        err = dc1394_set_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_DPC_CONTROL+4, 
+                                                 (uint32_t*) &sDPC.m_Mem,
+                                                 1 );
+        DC1394_ERR_RTN(err,"Could not set AVT advanced feature Defect Pixel Correction - Mem Control");
+
+        err = dc1394_avt_read_gpdata(camera, (unsigned char *) &DestBuffer[0].m_all, nDpcDataSize);
+        DC1394_ERR_RTN(err,"Could not download Data via AVT GPData buffer");
+
+        // Disable read access.
+        sDPC.m_Mem.m_bEnaMemRD = 0;
+        sDPC.m_Mem.m_bEnaMemWR = 0;
+        sDPC.m_Mem.m_nAddrOffset = 0;
+        err = dc1394_set_adv_control_registers ( camera, 
+                                                 REG_CAMERA_AVT_DPC_CONTROL+4, 
+                                                 (uint32_t*) &sDPC.m_Mem,
+                                                 1 );
+        DC1394_ERR_RTN(err,"Could not set AVT advanced feature Defect Pixel Correction - Mem Control");
+    }
+    *PixelCount = nDpcDataSize/4;
+    return DC1394_SUCCESS;
+}
+
+
+/************************************************************************/
+/* Write Defect Pixel Correction Data                                   */
+/************************************************************************/
+dc1394error_t dc1394_avt_write_dpc_data(dc1394camera_t                *camera,
+                                        dc1394_avt_dpc_pixel_position *SourceBuffer,
+                                        uint32_t                      PixelCount)
+{
+    dc1394error_t                               err;
+    dc1394_avt_csradv_defect_pixel_correction_t sDPC;
+
+    /* get registers */
+    err = dc1394_get_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL, 
+                                             (uint32_t*) &sDPC.m_Ctrl,
+                                             sizeof(dc1394_avt_csradv_defect_pixel_correction_t)/4 );
+    DC1394_ERR_RTN(err,"Could not get AVT advanced feature Defect Pixel Correction");
+
+
+    // Get amount of data to store and size of GP data buffer.
+    uint32_t nDpcDataSize = PixelCount * 4;
+
+    // Enable write access.
+    sDPC.m_Mem.m_bEnaMemRD = 0;
+    sDPC.m_Mem.m_bEnaMemWR = 1;
+    sDPC.m_Mem.m_nAddrOffset = 0;
+    err = dc1394_set_adv_control_registers ( camera, 
+                                             REG_CAMERA_AVT_DPC_CONTROL+4, 
+                                             (uint32_t*) &sDPC.m_Mem,
+                                             1 );
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Defect Pixel Correction - Mem Control");
+
+    err = dc1394_avt_write_gpdata (camera, (unsigned char *) &SourceBuffer[0].m_all, nDpcDataSize);
+    DC1394_ERR_RTN(err,"Could not upload data via AVT GPData buffer");
+
+    // Disable write access.
+    sDPC.m_Mem.m_bEnaMemRD = 0;
+    sDPC.m_Mem.m_bEnaMemWR = 0;
+    sDPC.m_Mem.m_nAddrOffset = 0;
+    DC1394_ERR_RTN(err,"Could not set AVT advanced feature Defect Pixel Correction - Mem Control");
+    return DC1394_SUCCESS;
+}
\ Brak znaku nowej linii na kocu pliku
diff -Nur libdc1394-2.1.2/dc1394/vendor/avt_csr_structs_adv.h libdc1394_avt-2.1.2/dc1394/vendor/avt_csr_structs_adv.h
--- libdc1394-2.1.2/dc1394/vendor/avt_csr_structs_adv.h	1970-01-01 01:00:00.000000000 +0100
+++ libdc1394_avt-2.1.2/dc1394/vendor/avt_csr_structs_adv.h	2010-01-12 14:10:00.000000000 +0100
@@ -0,0 +1,1235 @@
+/*
+ * 1394-Based Digital Camera Control Library
+ *
+ * AVT Advanced Feature Helper Struct Definitions
+ *
+ * The original version of this file is distributed with the AVT FirePackage 
+ * for Windows, as part of the 'FireGrab' programming examples.
+ *
+ * Copyright (C) 2010 Allied Vision Technologies GmbH
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef __CSR_STRUCTS_ADV_H
+#define __CSR_STRUCTS_ADV_H
+
+#include <types.h>
+
+#define DC1394_AVT_NUM_FORMAT7_MODES       8
+
+/*****************************************************************************
+    Helper struct definitions originally used for standard IIDC features
+*****************************************************************************/
+
+typedef struct __dc1394_avt_imagepos_struct
+{
+    uint16_t                m_nTop;
+    uint16_t                m_nLeft;
+} dc1394_avt_imagepos_t;
+
+typedef struct __dc1394_avt_imagesize_struct
+{
+    uint16_t                m_nHeight;
+    uint16_t                m_nWidth;
+} dc1394_avt_imagesize_t;
+
+typedef struct __dc1394_avt_aoi_struct
+{
+    dc1394_avt_imagepos_t             m_imgPos;
+    dc1394_avt_imagesize_t            m_imgSize;
+} dc1394_avt_aoi_t;
+
+typedef union __dc1394_avt_csr_whitebal_inq_union
+{
+    struct __tagBrightnessInqElems
+    {
+        uint32_t                m_nMaxVal       : 12;
+        uint32_t                m_nMinVal       : 12;
+        uint32_t                m_bManual       :  1;
+        uint32_t                m_bAuto         :  1;
+        uint32_t                m_bOnOff        :  1;
+        uint32_t                m_bReadOut      :  1;
+        uint32_t                m_bOnePush      :  1;
+        uint32_t                                :  1;
+        uint32_t                m_bAbsControl   :  1;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csr_whitebal_inq_t;
+
+/*****************************************************************************
+    Advanced feature registers
+*****************************************************************************/
+
+#define DC1394_AVT_CSR_MAX_AFECHN      4
+
+
+// ---------------------------------------------------------------------------
+//
+typedef struct __dc1394_avt_csradv_version_info_struct
+{
+    uint16_t                    m_nArmVersion;      //  2 Bytes
+    uint16_t                    m_nArmSpecID;       //  2 Bytes
+    uint32_t                    m_nArmVersionEx;    //  4 Bytes
+    uint16_t                    m_nFpgaVersion;     //  2 Bytes
+    uint16_t                    m_nFpgaSpecID;      //  2 Bytes
+    uint32_t                    m_nFpgaVersionEx;   //  4 Bytes
+} dc1394_avt_csradv_version_info_t;
+
+typedef struct __dc1394_avt_csradv_version_info_ex_struct
+{
+    dc1394_avt_csradv_version_info_t    m_Rev;
+
+    uint64_t                            gap3[2];            // 16 Bytes
+
+    uint64_t                            m_nOrderID;         //  8 Bytes
+    uint64_t                            m_nCustomerKey;     //  8 Bytes
+} dc1394_avt_csradv_version_info_ex_t;
+
+// ---------------------------------------------------------------------------
+// Inquiry of available advanced features
+typedef struct __dc1394_avt_smart_feature_info_full_struct
+{
+    uint32_t        Size;
+
+    /* Camera capabilities provided as user information. */
+    dc1394bool_t    MaxResolution;
+    dc1394bool_t    TimeBase;
+    dc1394bool_t    ExtdShutter;
+    dc1394bool_t    TestImage;
+    dc1394bool_t    FrameCounter;
+    dc1394bool_t    Sequences;
+    dc1394bool_t    VersionInfo;
+    dc1394bool_t    Lookup_Tables;
+    dc1394bool_t    Shading;
+    dc1394bool_t    DeferredTransport;
+    dc1394bool_t    HDR_Mode;
+    dc1394bool_t    DSNU;
+    dc1394bool_t    BlemishCorrection;
+    dc1394bool_t    TriggerDelay;
+    dc1394bool_t    MirrorImage;
+    dc1394bool_t    SoftReset;
+    dc1394bool_t    HSNR;
+    dc1394bool_t    ColorCorrection;
+    dc1394bool_t    ColorAvg;
+    dc1394bool_t    SIS;
+    dc1394bool_t    UserProfiles;
+    dc1394bool_t    TriggerCounter;
+    dc1394bool_t    ParamListBuffer;
+    dc1394bool_t    GP_Buffer;
+
+    dc1394bool_t    Input_1;
+    dc1394bool_t    Input_2;
+    dc1394bool_t    Input_3;
+    dc1394bool_t    Input_4;
+    dc1394bool_t    Input_5;
+    dc1394bool_t    Input_6;
+    dc1394bool_t    Input_7;
+    dc1394bool_t    Input_8;
+    dc1394bool_t    Output_1;
+    dc1394bool_t    Output_2;
+    dc1394bool_t    Output_3;
+    dc1394bool_t    Output_4;
+    dc1394bool_t    Output_5;
+    dc1394bool_t    Output_6;
+    dc1394bool_t    Output_7;
+    dc1394bool_t    Output_8;
+    dc1394bool_t    IntEnaDelay;
+    dc1394bool_t    IncDecoder;
+    dc1394bool_t    Output_1_PWM;
+    dc1394bool_t    Output_2_PWM;
+    dc1394bool_t    Output_3_PWM;
+    dc1394bool_t    Output_4_PWM;
+    dc1394bool_t    Output_5_PWM;
+    dc1394bool_t    Output_6_PWM;
+    dc1394bool_t    Output_7_PWM;
+    dc1394bool_t    Output_8_PWM;
+
+    dc1394bool_t    CameraStatus;
+    dc1394bool_t    MaxIsoSize_S400;
+    dc1394bool_t    MaxIsoSize_S800;
+    dc1394bool_t    ParamUpdTiming;
+    dc1394bool_t    F7ModeMapping;
+    dc1394bool_t    AutoShutter;
+    dc1394bool_t    AutoGain;
+    dc1394bool_t    AutoFunctionAOI;
+    dc1394bool_t    SequenceStep;
+    dc1394bool_t    LowNoiseBinning;
+    dc1394bool_t    GlobalResetReleaseShutter;
+    dc1394bool_t    DefectPixelCorrection;
+    dc1394bool_t    SWFeatureControl;
+    dc1394bool_t    LedBlanking;
+    dc1394bool_t    InputDebounce_1;
+    dc1394bool_t    InputDebounce_2;
+    dc1394bool_t    InputDebounce_3;
+    dc1394bool_t    InputDebounce_4;
+    dc1394bool_t    InputDebounce_5;
+    dc1394bool_t    InputDebounce_6;
+    dc1394bool_t    InputDebounce_7;
+    dc1394bool_t    InputDebounce_8;
+
+    dc1394bool_t    HDRPike;
+    dc1394bool_t    ChannelAdjustGain;
+    dc1394bool_t    LowSmear;
+    dc1394bool_t    AdvWhiteBal;
+    dc1394bool_t    ChannelAdjustOffset;
+
+    /* reserved space for future features */
+    dc1394bool_t    reserved[64];
+
+    /* Internal information used by libdc functions. */
+    struct __tagCsrAdvInfoInternal
+    {
+        struct __tagCsrAdvInq1
+        {
+            uint32_t                m_bGPBuffer         :  1;   // BIT31
+            uint32_t                m_bParamListBuffer  :  1;   // BIT30
+            uint32_t                                    :  5;   // BIT[25..29]
+            uint32_t                m_bTrgCounter       :  1;   // BIT24
+            uint32_t                m_bFrmCounter2      :  1;   // BIT23
+            uint32_t                m_bTimestamp2       :  1;   // BIT22
+            uint32_t                m_bUserProfiles     :  1;   // BIT21
+            uint32_t                m_bTimestamp        :  1;   // BIT20
+            uint32_t                m_bColorAvg         :  1;   // BIT19 (DF145C only)
+            uint32_t                m_bColorCorr        :  1;   // BIT18
+            uint32_t                m_bHighSNR          :  1;   // BIT17
+            uint32_t                m_bSoftReset        :  1;   // BIT16
+            uint32_t                m_bImageMirror      :  1;   // BIT15
+            uint32_t                m_bTriggerDelay     :  1;   // BIT14
+            uint32_t                m_bBlemishCorr      :  1;   // BIT13
+            uint32_t                m_bFpnCorrection    :  1;   // BIT12
+            uint32_t                m_bCmosHdrMode      :  1;   // BIT11
+            uint32_t                m_bDeferredTrans    :  1;   // BIT10
+            uint32_t                m_bShading          :  1;   // BIT9
+            uint32_t                m_bLut              :  1;   // BIT8
+            uint32_t                                    :  1;   // BIT7
+            uint32_t                m_bVersionInfo      :  1;   // BIT6
+            uint32_t                m_bSequences        :  1;   // BIT5
+            uint32_t                m_bFrameInfo        :  1;   // BIT4
+            uint32_t                m_bTestImage        :  1;   // BIT3
+            uint32_t                m_bExtdShutter      :  1;   // BIT2
+            uint32_t                m_bTimeBase         :  1;   // BIT1
+            uint32_t                m_bMaxResolution    :  1;   // BIT0
+        }                           Inq1;
+    
+        struct __tagCsrAdvInq2
+        {
+            uint32_t                m_bOutp_8_PWM       :  1;
+            uint32_t                m_bOutp_7_PWM       :  1;
+            uint32_t                m_bOutp_6_PWM       :  1;
+            uint32_t                m_bOutp_5_PWM       :  1;
+            uint32_t                m_bOutp_4_PWM       :  1;
+            uint32_t                m_bOutp_3_PWM       :  1;
+            uint32_t                m_bOutp_2_PWM       :  1;
+            uint32_t                m_bOutp_1_PWM       :  1;
+            uint32_t                                    :  6;
+            uint32_t                m_bIncDecoder       :  1;
+            uint32_t                m_bIntEnaDelay      :  1;
+            uint32_t                m_bOutp_8           :  1;
+            uint32_t                m_bOutp_7           :  1;
+            uint32_t                m_bOutp_6           :  1;
+            uint32_t                m_bOutp_5           :  1;
+            uint32_t                m_bOutp_4           :  1;
+            uint32_t                m_bOutp_3           :  1;
+            uint32_t                m_bOutp_2           :  1;
+            uint32_t                m_bOutp_1           :  1;
+            uint32_t                m_bInp_8            :  1;
+            uint32_t                m_bInp_7            :  1;
+            uint32_t                m_bInp_6            :  1;
+            uint32_t                m_bInp_5            :  1;
+            uint32_t                m_bInp_4            :  1;
+            uint32_t                m_bInp_3            :  1;
+            uint32_t                m_bInp_2            :  1;
+            uint32_t                m_bInp_1            :  1;
+        }                           Inq2;
+    
+        struct __tagCsrAdvInq3
+        {
+            uint32_t                m_bInpDebounce_8    :  1;
+            uint32_t                m_bInpDebounce_7    :  1;
+            uint32_t                m_bInpDebounce_6    :  1;
+            uint32_t                m_bInpDebounce_5    :  1;
+            uint32_t                m_bInpDebounce_4    :  1;
+            uint32_t                m_bInpDebounce_3    :  1;
+            uint32_t                m_bInpDebounce_2    :  1;
+            uint32_t                m_bInpDebounce_1    :  1;
+            uint32_t                                    : 10;
+            uint32_t                m_bSWFeatureCtrl    :  1;
+            uint32_t                m_bDpc              :  1;
+            uint32_t                m_bGlobResRelShutter:  1;
+            uint32_t                                    :  1;
+            uint32_t                m_bLowNoiseBinning  :  1;
+            uint32_t                m_bSIS              :  1;
+            uint32_t                m_bSequenceStep     :  1;
+            uint32_t                m_bAutoFncAOI       :  1;
+            uint32_t                m_bAutoGain         :  1;
+            uint32_t                m_bAutoShutter      :  1;
+            uint32_t                m_bF7ModeMapping    :  1;
+            uint32_t                m_bParamUpdTiming   :  1;
+            uint32_t                m_bMaxIsoSize       :  1;
+            uint32_t                m_bCameraStatus     :  1;
+        }                           Inq3;
+    
+        struct __tagCsrAdvInq4
+        {
+            uint32_t                                    : 27;
+            uint32_t                m_bPikeChannelOffset:  1;
+            uint32_t                m_bAdvWhiteBal      :  1;
+            uint32_t                m_bLowSmear         :  1;
+            uint32_t                m_bPikeChannelComp  :  1;
+            uint32_t                m_bPikeHdrMode      :  1;
+        }                           Inq4;
+    } Internal;
+} dc1394_avt_smart_feature_info_full_t;
+
+/* Camera status register
+ */
+typedef struct __dc1394_avt_csradv_camstatus_struct
+{
+    uint32_t                    m_nImplID;          //!< presence + impl ID
+    uint32_t                    m_nStatus;
+} dc1394_avt_csradv_camstatus_t;
+
+/* Max resolution information register
+ */
+typedef union __dc1394_avt_csradv_max_resolution_union
+{
+    dc1394_avt_imagesize_t      m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_max_resolution_t;
+
+// ---------------------------------------------------------------------------
+//
+typedef union __dc1394_avt_csradv_timebase_union
+{
+    struct __tagCsrAdvTimebaseElems
+    {
+        uint32_t                m_nBase         :  4;   //! shutter time base ID
+        uint32_t                                :  8;
+        uint32_t                m_nExpOffset    : 12;   //! camera specific exposure offset in uSec
+        uint32_t                                :  7;
+        uint32_t                m_bPresence     :  1;   //! presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_timebase_t;
+
+typedef union __dc1394_avt_csradv_extd_shutter_union
+{
+    struct __tagCsrAdvExtdShutterElems
+    {
+        uint32_t                m_nShutter      : 26;
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_extd_shutter_t;
+
+typedef union __dc1394_avt_csradv_trigger_delay_union
+{
+    struct __tagCsrAdvTriggerDelayElems
+    {
+        uint32_t                m_nDelay        : 21;
+        uint32_t                                :  4;
+        uint32_t                m_bOnOff        :  1;
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_trigger_delay_t;
+
+// ---------------------------------------------------------------------------
+//
+typedef union __dc1394_avt_csradv_testpix_union
+{
+    struct __tagCsrAdvTestPixElems
+    {
+        uint32_t                m_nTestPix      :  4;
+        uint32_t                                : 13;
+        uint32_t                m_bImg7Inq      :  1;   // Image 7 present
+        uint32_t                m_bImg6Inq      :  1;   // Image 6 present
+        uint32_t                m_bImg5Inq      :  1;   // Image 5 present
+        uint32_t                m_bImg4Inq      :  1;   // Image 4 present
+        uint32_t                m_bImg3Inq      :  1;   // Image 3 present
+        uint32_t                m_bImg2Inq      :  1;   // Image 2 present
+        uint32_t                m_bImg1Inq      :  1;   // Image 1 present
+        uint32_t                                :  7;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_testpix_t;
+
+// ---------------------------------------------------------------------------
+// Sequence control and parameter
+typedef union __dc1394_avt_csradv_seqctrl_union
+{
+    struct __tagCsrAdvSeqParamElems
+    {
+        uint32_t                m_nSeqLength    :  8;   //!< user selected sequence length
+        uint32_t                m_nMaxLength    :  8;   //!< max sequence length (read-only)
+        uint32_t                m_nSeqMode      :  8;   //!< sequence mode
+        uint32_t                m_bSetupMode    :  1;   //!< sequence setup mode
+        uint32_t                m_bOnOff        :  1;   //!< sequence enabled/disabled
+        uint32_t                m_bAutoRewind   :  1;   //!< auto reqwind sequence at the end
+        uint32_t                                :  4;
+        uint32_t                m_bPresence     :  1;   //!< presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_seqctrl_t;
+
+typedef union __dc1394_avt_csradv_seqparam_union
+{
+    struct __tagCsrAdvSeqCtrlElems
+    {
+        uint32_t                m_nImageNo      :  8;   //!< sequence item index (0..n)
+        uint32_t                m_nImgRep       :  8;   //!< repeat count of sequence item
+        uint32_t                m_nSeqMode      :  8;   //!< sequence mode
+        uint32_t                                :  1;
+        uint32_t                m_bIncImgNo     :  1;   //!< increment m_nImageNo on m_bApply
+        uint32_t                m_bApply        :  1;
+        uint32_t                                :  5;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_seqparam_t;
+
+typedef union __dc1394_avt_csradv_seqstep_union
+{
+    struct __tagCsrAdvSeqStepElems
+    {
+        uint32_t                m_nSeqPos       :  8;   //!< current sequence position
+        uint32_t                                : 17;
+        uint32_t                m_bReset        :  1;   //!< perform sequence reset
+        uint32_t                m_bStep         :  1;   //!< perform sequence step
+        uint32_t                                :  4;
+        uint32_t                m_bPresence     :  1;   //!< presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_seqstep_t;
+
+typedef struct __dc1394_avt_csradv_sequence_struct
+{
+    dc1394_avt_csradv_seqctrl_t      m_Ctrl;
+    dc1394_avt_csradv_seqparam_t     m_Param;
+} dc1394_avt_csradv_sequence_t;
+
+// ---------------------------------------------------------------------------
+// Lut control
+//#define DC1394_AVT_LUT_TABLE_SIZE          8192
+//#define DC1394_AVT_LUT_NUMOFTABLES         64
+
+typedef struct __dc1394_avt_csradv_lut_ctrl_struct
+{
+    // Lut control
+    struct __tagCsrAdvLutCtrlElems
+    {
+        uint32_t                m_nLutNo        :  6;   //! number of table to use
+        uint32_t                                :  2;
+        uint32_t                m_nMemChn       :  8;   //! memory channel to save/load data to/from
+        uint32_t                                :  6;
+        uint32_t                m_bMemLoad      :  1;   //! load LUT data from channel n
+        uint32_t                m_bMemSave      :  1;   //! save LUT data to channel n
+        uint32_t                                :  1;
+        uint32_t                m_bOnOff        :  1;
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;
+    }                           m_Ctrl;
+
+    struct __tagCsrAdvLutMemElems
+    {
+        uint32_t                m_nAddrOffset   : 16;   //! address offset to selected LUT
+        uint32_t                m_nLut2WR       :  8;   //! number of LUT to access
+        uint32_t                                :  2;
+        uint32_t                m_bEnaMemWR     :  1;
+        uint32_t                                :  4;
+        uint32_t                m_bPresence     :  1;
+    }                           m_Mem;
+
+    struct __tagCsrAdvLutInfoElems
+    {
+        uint32_t                m_nMaxSize      : 16;   //! max size of one LUT
+        uint32_t                m_nNumOfLuts    :  8;   //! number of available LUTs
+        uint32_t                m_nBitsPerValue :  5;   //! number of bits/grey value
+        uint32_t                                :  2;
+        uint32_t                m_bPresence     :  1;   //
+    }                           m_Info;
+
+} dc1394_avt_csradv_lut_ctrl_t;
+
+// ---------------------------------------------------------------------------
+// Deferred transport
+typedef union __dc1394_avt_csradv_deferredtrans_union
+{
+    struct __tagCsrAdvDeferredTransElems
+    {
+        uint32_t                m_nSendPix      :  8;   //! number of images WR:to send, RD: left
+        uint32_t                m_nFifoDepth    :  8;   //! depth of image FIFO
+        uint32_t                                :  8;
+        uint32_t                m_bFastCapture  :  1;   //!
+        uint32_t                m_bHoldImg      :  1;   //!
+        uint32_t                m_bSendPix      :  1;   //!
+        uint32_t                                :  4;
+        uint32_t                m_bPresence     :  1;   //!
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_deferredtrans_t;
+
+// ---------------------------------------------------------------------------
+// IO input/output control
+#define DC1394_AVT_MAX_NUM_OF_INPUTS            8
+#define DC1394_AVT_MAX_NUM_OF_OUTPUTS           8
+
+typedef enum __dc1394_avt_csradv_inp_modes_enum
+{
+    DC1394_AVT_GPIO_INP_OFF                = 0,
+    DC1394_AVT_GPIO_INP_TRIGGER            = 0x02,
+    DC1394_AVT_GPIO_INP_DECODER            = 0x03,
+    DC1394_AVT_GPIO_INP_SEQSTEP_EDGE       = 0x04,     //!< sequence stepping on edge signal
+    DC1394_AVT_GPIO_INP_SEQSTEP_LEVEL      = 0x05,     //!< sequence stepping on level signal
+    DC1394_AVT_GPIO_INP_SEQ_RESET          = 0x06,     //!< sequence reset on edge signal
+} dc1394_avt_csradv_inp_modes_t;
+
+typedef union __dc1394_avt_csradv_io_inp_ctrlx_union
+{
+    struct __tagCsrAdvIoInpCtrlxElems
+    {
+        uint32_t                m_bPinState     :  1;   //!< pin input state
+        uint32_t                                : 15;
+        uint32_t                m_nMode         :  5;   //!< pin input mode
+        uint32_t                                :  3;
+        uint32_t                m_bPolarity     :  1;   //!< pin polarity
+        uint32_t                                :  5;
+        uint32_t                m_bIsBidir      :  1;   //!< pin is input & output pin
+        uint32_t                m_bPresence     :  1;   //!< pin is present
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_io_inp_ctrlx_t;
+
+typedef enum __dc1394_avt_csradv_io_outp_modes_enum
+{
+    DC1394_AVT_GPIO_OUTP_OFF               = 0,
+    DC1394_AVT_GPIO_OUTP_DIRECT            = 0x01,
+    DC1394_AVT_GPIO_OUTP_INTENA            = 0x02,
+    DC1394_AVT_GPIO_OUTP_DECODER           = 0x03,
+    DC1394_AVT_GPIO_OUTP_FVAL              = 0x06,
+    DC1394_AVT_GPIO_OUTP_BUSY              = 0x07,
+    DC1394_AVT_GPIO_OUTP_FOLLOW_INP        = 0x08,
+    DC1394_AVT_GPIO_OUTP_PWM               = 0x09,
+} dc1394_avt_csradv_io_outp_modes_t;
+
+typedef union __dc1394_avt_csradv_io_outp_ctrlx_union
+{
+    struct __tagCsrAdvIoOutpCtrlxElems
+    {
+        uint32_t                m_bPinState     :  1;   //!< pin readback state
+        uint32_t                                : 15;
+        uint32_t                m_nMode         :  5;   //!< pin mode
+        uint32_t                                :  3;
+        uint32_t                m_bPolarity     :  1;   //!< pin polartiy
+        uint32_t                                :  5;
+        uint32_t                m_bHasPwm       :  1;   //!< pin has PWM capability
+        uint32_t                m_bPresence     :  1;   //!< pin is present
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_io_outp_ctrlx_t;
+
+typedef struct __dc1394_avt_csradv_io_outp_pwmx_struct
+{
+    struct
+    {
+        uint32_t                                : 12;
+        uint32_t                m_nMinPeriod    : 16;   //! minimum PWM period in microseconds (aka max frequency)
+        uint32_t                                :  3;
+        uint32_t                m_bPresence     :  1;   //! presence of this feature
+    }                           m_Ctrl;
+
+    struct
+    {
+        uint32_t                m_nPeriod       : 16;   //!< PWM period in microseconds * timebase
+        uint32_t                m_nPulseWidth   : 16;   //!< PWM pulse width in microseconds * timebase
+    }                           m_Pwm;
+} dc1394_avt_csradv_io_outp_pwmx_t;
+
+// integration enable delay
+typedef union __dc1394_avt_csradv_intena_delay_union
+{
+    struct __tagCsrAdvIntEnaDelayElems
+    {
+        uint32_t                m_nDelay1us     : 20;
+        uint32_t                                :  5;
+        uint32_t          m_bOnOff        :  1;
+        uint32_t                                :  5;
+        uint32_t            m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_intena_delay_t;
+
+// incremental decoder
+typedef struct __dc1394_avt_csradv_decoder_struct
+{
+    struct __tagCsrAdvDecoderCtrl
+    {
+        uint32_t                                : 24;
+        uint32_t          m_bClearCounter :  1;
+        uint32_t          m_bOnOff        :  1;
+        uint32_t                                :  5;
+        uint32_t            m_bPresence     :  1;
+    }                           m_Ctrl;
+
+    struct __tagCsrAdvDecoderValues
+    {
+        uint32_t                m_nCounter      : 12;
+        uint32_t                                :  4;
+        uint32_t                m_nCompare      : 12;
+        uint32_t                                :  4;
+    }                           m_Val;
+
+} dc1394_avt_csradv_decoder_t;
+
+typedef struct
+{
+    dc1394_avt_csradv_io_inp_ctrlx_t         m_ioInp[DC1394_AVT_MAX_NUM_OF_INPUTS];
+} dc1394_avt_csradv_io_inp_ctrls_t;
+
+typedef struct
+{
+    dc1394_avt_csradv_io_outp_ctrlx_t        m_ioOutp[DC1394_AVT_MAX_NUM_OF_OUTPUTS];
+} dc1394_avt_csradv_io_outp_ctrls_t;
+
+typedef struct
+{
+    dc1394_avt_csradv_io_inp_ctrlx_t         m_ioInp[DC1394_AVT_MAX_NUM_OF_INPUTS];
+    dc1394_avt_csradv_io_outp_ctrlx_t        m_ioOutp[DC1394_AVT_MAX_NUM_OF_OUTPUTS];
+} dc1394_avt_csradv_io_ctrl_t;
+
+typedef struct
+{
+    dc1394_avt_csradv_io_outp_pwmx_t         m_ioOutp[DC1394_AVT_MAX_NUM_OF_OUTPUTS];
+} dc1394_avt_csradv_io_pwm_t;
+
+
+/**
+ *  Advanced feature input debounce control
+ */
+typedef struct __dc1394_avt_csradv_io_inp_debounce_x_struct
+{
+    union __tagCsrAdvIoInpDebounceCtrl
+    {
+        struct __tagCsrAdvIoInpDebounceElems
+        {
+            uint32_t            m_nDebTime      : 24;   //!< input debounce time in 500ns steps
+            uint32_t                            :  7;
+            uint32_t            m_bPresence     :  1;   //!< presence of this feature
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_Ctrl;
+
+    uint32_t                    m_nMinDebTime;          //!< minimum debounce time
+    uint32_t                    m_nMaxDebTime;          //!< maximum debounce time
+    uint32_t                    m_gap;
+} dc1394_avt_csradv_io_inp_debounce_x;
+
+typedef struct
+{
+    dc1394_avt_csradv_io_inp_debounce_x    m_ioInp[DC1394_AVT_MAX_NUM_OF_INPUTS];
+} dc1394_avt_csradv_io_inp_debounce;
+
+// ---------------------------------------------------------------------------
+// Serial function control
+typedef union __dc1394_avt_csradv_serialfunction_union
+{
+    struct __tagCsrAdvSerialFunctionElems
+    {
+        uint32_t                m_nFuncID       : 16;
+        uint32_t                m_nBitrateID    :  8;
+        uint32_t                                :  7;
+        uint32_t            m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_serialfunction_t;
+
+// ---------------------------------------------------------------------------
+// Shading control
+typedef struct __dc1394_avt_csradv_shading_struct
+{
+    struct __tagCsrAdvShadingCtrl
+    {
+        uint32_t                m_nGrabCount    :  8;   //! number of images to build shading image
+        uint32_t                m_nMemChn       :  4;   //! memory channel to save/load shading image to/from
+        uint32_t                m_nMemChnError  :  4;   //! indicates any memory channel errors
+        uint32_t                                :  5;
+        uint32_t          m_bMemClear     :  1;   //! clear shading image from channel n
+        uint32_t          m_bMemLoad      :  1;   //! load shading image from channel n
+        uint32_t          m_bMemSave      :  1;   //! save shading image to channel n
+        uint32_t            m_bBusy         :  1;   //! build shading image in progress
+        uint32_t          m_bOnOff        :  1;   //! shading on/off
+        uint32_t          m_bBuildTable   :  1;   //! build shading image now
+        uint32_t          m_bShowImg      :  1;   //! show shading data as image
+        uint32_t                                :  2;
+        uint32_t            m_bBuildError   :  1;   //! build shading image reports an error
+        uint32_t            m_bPresence     :  1;   //! Presence of this feature
+    }                           m_Ctrl;
+
+    struct __tagCsrAdvShadingMem
+    {
+        uint32_t                m_nAddrOffset   : 24;   //! wr: set address offset
+                                                        //! rd: get address offset
+        uint32_t                                :  1;
+        uint32_t          m_bEnaMemRD     :  1;   //! enable RD access
+        uint32_t          m_bEnaMemWR     :  1;   //! enable WR access
+        uint32_t                                :  4;
+        uint32_t            m_bPresence     :  1;   //! Presence of this feature
+    }                           m_Mem;
+
+    struct __tagCsrAdvShadingInfo
+    {
+        uint32_t                m_nMaxSize      : 24;   // max size of shading image
+        uint32_t                m_nMemChnCount  :  4;   // number of available memory channels
+        uint32_t                                :  3;
+        uint32_t            m_bPresence     :  1;   // Presence of this feature
+    }                           m_Info;
+} dc1394_avt_csradv_shading_t;
+
+// ---------------------------------------------------------------------------
+// FPN & Blemish correction control
+typedef union __dc1394_avt_csradv_dsnucorrection_union
+{
+    struct __tagCsrAdvDsnuCorrectionCtrl
+    {
+        uint32_t                m_nGrabCount    :  8;   // number of images to build FPN image
+        uint32_t                m_nMemChn       :  4;   // memory channel to save/load FPN image to/from
+        uint32_t                                :  9;
+        uint32_t                m_bZeroTable    :  1;   // zero the FPN image buffer
+        uint32_t                m_bMemLoad      :  1;   // load FPN image from storage
+        uint32_t                m_bMemSave      :  1;   // save FPN image to storage
+        uint32_t                m_bBusy         :  1;   // build FPN image in progress
+        uint32_t                m_bOnOff        :  1;   // FPN correction on/off
+        uint32_t                m_bBuildTable   :  1;   // build shading image now
+        uint32_t                m_bShowImg      :  1;   // show shading data as image
+        uint32_t                                :  2;
+        uint32_t                m_bBuildError   :  1;   // build FPN image reports an error
+        uint32_t                m_bPresence     :  1;   // Presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_dsnucorrection_t, dc1394_avt_csradv_blemishcorrection_t;
+
+// ---------------------------------------------------------------------------
+// Defect Pixel Correction control
+typedef struct __dc1394_avt_csradv_defect_pixel_correction_struct
+{
+    struct __tagCsrAdvDefectPixelCorrectionCtrlElems
+    {
+        uint32_t                m_nThreshold    :  7;    //!< threshold for DP correction
+        uint32_t                m_nMean         :  7;      //!< calculated mean value 
+        uint32_t                                :  7;
+        uint32_t                m_bZeroDPData   :  1;    //!< zero DP data
+        uint32_t                m_bMemLoad      :  1;    //!< load DP data from storage
+        uint32_t                m_bMemSave      :  1;    //!< save DP data to storage
+        uint32_t                m_bBusy         :  1;    //!< build DP data in progress
+        uint32_t                m_bOnOff        :  1;    //!< DP correction on/off
+        uint32_t                m_bBuildDPData  :  1;    //!< build DP data now
+        uint32_t                                :  3;
+        uint32_t                m_bBuildError   :  1;    //!< build DP data reports an error
+        uint32_t                m_bPresence     :  1;    //!< presence of this feature
+    }                           m_Ctrl;
+
+    struct __tagCsrAdvDefectPixelCorrectionMemElems
+    {
+        uint32_t                m_nAddrOffset    : 14;   //!< address offset to selected DP data
+        uint32_t                m_nDPDataSize    : 14;   //!< size of DP data to read (from Ram to Host)
+        uint32_t                m_bEnaMemRD      :  1;   //!< enable RD access (from Ram to Host)
+        uint32_t                m_bEnaMemWR      :  1;   //!< enable WR access (from Host to Ram)
+        uint32_t                                 :  1;
+        uint32_t                m_bPresence      :  1;   //!< presence of this feature
+    }                           m_Mem;
+
+    struct __tagCsrAdvDefectPixelCorrectionInfoElems
+    {
+        uint32_t                m_nMaxSize       : 14;   //!< max size of the DP data
+        uint32_t                m_nMaxThreshold  :  7;   //!< max value for threshold
+        uint32_t                m_nMinThreshold  :  7;   //!< min value for threshold
+        uint32_t                                 :  3;
+        uint32_t                m_bPresence      :  1;   //!< presence of this feature
+    }                              m_Info;      
+} dc1394_avt_csradv_defect_pixel_correction_t;
+
+// ---------------------------------------------------------------------------
+// soft reset
+typedef union __dc1394_avt_csradv_softreset_union
+{
+    struct __tagCsrAdvSoftResetElems
+    {
+        uint32_t                m_nDelay10ms    : 12;
+        uint32_t                                : 13;
+        uint32_t                m_bReset        :  1;   //! restart current firmware set
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_softreset_t;
+
+// ---------------------------------------------------------------------------
+// Local Color Anti Aliasing
+typedef union __dc1394_avt_csradv_coloravg_union
+{
+    struct __tagCsrAdvColorAvgElems
+    {
+        uint32_t                                : 25;
+        uint32_t                m_bOnOff        :  1;
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_coloravg_t;
+
+// ---------------------------------------------------------------------------
+// general purpose data buffer
+
+#define DC1394_AVT_CSRADV_GPDATABUFFER_SIZE    2048
+
+typedef union __dc1394_avt_csradv_gpdatainfo_union
+{
+    struct __tagCsrAdvGpDataInfoElems
+    {
+        uint32_t                m_nSize         : 16;
+        uint32_t                                : 16;
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_gpdatainfo_t;
+
+typedef union __dc1394_avt_csradv_gpdatabuffer_union
+{
+    uint16_t                    m_int16[DC1394_AVT_CSRADV_GPDATABUFFER_SIZE/sizeof(uint16_t)];
+    uint32_t                    m_int32[DC1394_AVT_CSRADV_GPDATABUFFER_SIZE/sizeof(uint32_t)];
+} dc1394_avt_csradv_gpdatabuffer_t;
+
+// ---------------------------------------------------------------------------
+//
+typedef struct __dc1394_avt_csradv_frameinfo_struct
+{
+    struct __tagCsrAdvFrameInfoElems
+    {
+        uint32_t                                        : 30;
+        uint32_t                m_bClearFrameCounter    :  1;
+        uint32_t                m_bPresence             :  1;
+    }                           m_Cmd;
+
+    uint32_t                    m_nFrameCounter;
+
+} dc1394_avt_csradv_frameinfo_t;
+
+/*
+ *  IBIS5x HDR control register - extended for the MT9V022
+ *
+ *  @remarks The MT9V022 HDR mode requires multiple values per knee-point
+ *  @arg 3x voltage and 1x shutter value for a single knee-point
+ *  @arg 4x voltage and 2x shutter values for two knee-points
+ */
+typedef struct __dc1394_avt_csradv_hdr_struct
+{
+    struct __tagCsrAdvHdrElems
+    {
+        uint32_t                m_nKneePoints       :  4;       //!< selected number of knee-points
+        uint32_t                                    :  4;
+        uint32_t                m_nMaxKneePoints    :  4;       //!< max supported number of knee-points
+        uint32_t                                    : 13;
+        uint32_t                m_bOnOff            :  1;       //!< HDR mode on/off
+        uint32_t                                    :  5;
+        uint32_t                m_bPresence         :  1;       //!< feature presence
+    }                           m_Cmd;
+
+    struct __tagCsrAdvHdrKneePoints
+    {
+        uint16_t                m_nTime;                        //!< knee-point time
+        uint8_t                 m_nVoltage2;                    //!< knee-point voltage 2, 4, 6
+        uint8_t                 m_nVoltage1;                    //!< knee-point voltage 1, 3, 5
+    }                           m_kneePoint[3];
+
+} dc1394_avt_csradv_hdr_t;
+
+/*
+ *  Pike HDR control register
+ */
+typedef struct __dc1394_avt_csradv_hdr_pike_struct
+{
+    struct __tagCsrAdvHdrPikeElems
+    {
+        uint32_t                m_nKneeVoltage      :  8;       //!< reset voltage
+        uint32_t                                    : 17;
+        uint32_t                m_bOnOff            :  1;       //!< HDR mode on/off
+        uint32_t                                    :  5;
+        uint32_t                m_bPresence         :  1;       //!< feature presence
+    }                           m_Cmd;
+
+    uint32_t                    m_kneeTime1us;                  //!
+} dc1394_avt_csradv_hdr_pike_t;
+
+// ---------------------------------------------------------------------------
+// Global Reset Release shutter mode register
+typedef struct __dc1394_avt_csradv_global_res_rel_shutter_struct
+{
+    struct __tagCsrAdvGlobalResRelShutterElems
+    {
+        uint32_t                                 :  25;
+        uint32_t                m_bOnOff         :  1;      //!< enable global reset release shutter
+        uint32_t                                 :  5;
+        uint32_t                m_bPresence      :  1;      //!< presence of this feature
+    }                           m_Ctrl;
+} dc1394_avt_csradv_global_res_rel_shutter_t;
+
+// ---------------------------------------------------------------------------
+// color correction (8 quadlets)
+typedef struct __dc1394_avt_csradv_colorcorrection_struct
+{
+    struct __tagCsrAdvColorCorrectionElems
+    {
+        uint32_t                                    : 24;
+        uint32_t                m_bReset            :  1;
+        uint32_t                m_bOff              :  1;
+        uint32_t                                    :  5;
+        uint32_t                m_bPresence         :  1;
+    }                           m;
+
+    struct __tagCsrAdvColorCorrectionMatrix
+    {
+        uint32_t                m_nR1[3];
+        uint32_t                m_nR2[3];
+        uint32_t                m_nR3[3];
+    }                           m_Matrix;
+} dc1394_avt_csradv_colorcorrection_t;
+
+// ---------------------------------------------------------------------------
+// AutoShutterControl
+typedef struct __dc1394_avt_csradv_autoshutter_struct
+{
+    struct __tagCsrAdvAutoShutterElems
+    {
+        uint32_t                                    : 31;
+        uint32_t                m_bPresence         :  1;
+    }                           m;
+
+    struct __tagCsrAdvAutoShutterMinElems
+    {
+        uint32_t                m_nValue            : 26;
+        uint32_t                                    :  6;
+    }                           m_Low;
+
+    struct __tagCsrAdvAutoShutterMaxElems
+    {
+        uint32_t                m_nValue            : 26;
+        uint32_t                                    :  6;
+    }                           m_High;
+} dc1394_avt_csradv_autoshutter_t;
+
+// ---------------------------------------------------------------------------
+// AutoGainControl
+typedef union __dc1394_avt_csradv_autogain_union
+{
+    struct __tagCsrAdvAutoGainElems
+    {
+        uint32_t                m_nLoVal            : 12;
+        uint32_t                                    :  4;
+        uint32_t                m_nHiVal            : 12;
+        uint32_t                                    :  3;
+        uint32_t                m_bPresence         :  1;
+    }                           m;
+
+    uint32_t                    m_All;
+} dc1394_avt_csradv_autogain_t;
+
+// ---------------------------------------------------------------------------
+// AutoFeatureAOI
+typedef struct __dc1394_avt_csradv_autofnc_aoi_struct
+{
+    struct __tagCsrAdvAutoFncAOIElems
+    {
+        uint32_t                m_nXUnits           :  12;  //!< allowed position & size increment
+        uint32_t                m_nYUnits           :  12;  //!< allowed position & size increment
+        uint32_t                                    :  1;
+        uint32_t                m_bOnOff            :  1;
+        uint32_t                                    :  1;
+        uint32_t                m_bShowWorkArea     :  1;
+        uint32_t                                    :  3;
+        uint32_t                m_bPresence         :  1;
+    }                           m_Ctrl;
+
+    dc1394_avt_imagepos_t                  m_ImagePos;                 //!< area position
+    dc1394_avt_imagesize_t                 m_ImageSize;                //!< area size
+} dc1394_avt_csradv_autofnc_aoi_t;
+
+// ---------------------------------------------------------------------------
+// Low Smear feature
+typedef struct __dc1394_avt_csradv_low_smear_struct
+{
+    struct __tagCsrAdvLowSmearElems
+    {
+        uint32_t                                    :  25;
+        uint32_t                m_bOnOff            :  1;
+        uint32_t                                    :  5;
+        uint32_t                m_bPresence         :  1;
+    }                           m_Ctrl;
+} dc1394_avt_csradv_low_smear_t;
+
+/**
+ *  Image mirror register definition.
+ *
+ *  @remarks
+ *  \arg The former name of this register was MISC_FEATURES
+ *  \arg The m_MNR member has been kept for compatibility with older Marlin
+ *  software versions. Nevertheless the MNR features has been removed from
+ *  recent Marlin software versions.
+ */
+typedef struct __dc1394_avt_csradv_image_mirror_struct
+{
+    struct __tagCsrAdvImageMirrorElems
+    {
+        uint32_t                                    :  14;
+        uint32_t                m_bVertInq          :  1;   //!< vertical mirror presence
+        uint32_t                m_bHorzInq          :  1;   //!< horizontal mirror presence
+        uint32_t                                    :  8;
+        uint32_t                m_bVertOnOff        :  1;   //!< vertical mirror on/off
+        uint32_t                m_bHorzOnOff        :  1;   //!< horizontal mirror on/off
+        uint32_t                                    :  5;
+        uint32_t                m_bPresence         :  1;   //!< feature presence
+    }                           m_Mirror;
+
+    //! preserve compatibility with Marlin series
+    uint32_t                    m_MNR;
+
+} dc1394_avt_csradv_image_mirror_t;
+
+// ---------------------------------------------------------------------------
+//
+typedef struct __dc1394_avt_csradv_high_snr_struct
+{
+    union __tagCsrAdvHighSNRCtrl
+    {
+        struct __tagCsrAdvHighSNRCtrlElems
+        {
+            uint32_t            m_nGrabCount    :  9;
+            uint32_t                            : 16;
+            uint32_t            m_bOnOff        :  1;
+            uint32_t                            :  5;
+            uint32_t            m_bPresence     :  1;
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_Ctrl;
+
+    uint16_t                    m_nReserved[4];
+} dc1394_avt_csradv_high_snr_t;
+
+typedef struct __dc1394_avt_csradv_imagestamp_struct
+{
+    union __tagCsrAdvImageStampCtrl
+    {
+        struct __tagCsrAdvImageStampElems
+        {
+            uint32_t            m_nLinePos              : 16;   // signed line position of imagestamp
+            uint32_t            m_nTMode                :  3;   // format/mode of imagestamp data
+            uint32_t            m_bMode4Inq             :  1;   // b12: Mode 4 present
+            uint32_t            m_bMode3Inq             :  1;   // b11: Mode 3 present
+            uint32_t            m_bMode2Inq             :  1;   // b10: Mode 2 present
+            uint32_t            m_bMode1Inq             :  1;   // b09: Mode 1 present
+            uint32_t            m_bMode0Inq             :  1;   // b08: Mode 0 present -> GPLX CYCLE_TIMER
+            uint32_t            m_bSwap                 :  1;   // b07: byte swap of timestamp data
+            uint32_t            m_bOnOff                :  1;   // b06: enable insertion of timestamp data into image data
+            uint32_t                                    :  4;
+            uint32_t            m_bReset                :  1;   // b01: reset counter
+            uint32_t            m_bPresence             :  1;   // b00: presence of this feature
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_Ctrl;
+
+    uint32_t                    m_nStampData;
+
+} dc1394_avt_csradv_imagestamp_t;
+
+/**
+ * 	SIS control structure
+ */
+typedef struct __dc1394_avt_csradv_sis_struct
+{
+    union __tagCsrAdvSisCtrl
+    {
+        struct __tagCsrAdvSisElems
+        {
+            uint32_t                m_nLineNo       : 16;   //! SIS data position inside an image
+            uint32_t                                :  9;
+            uint32_t                m_bOnOff        :  1;   //! SIS on/off
+            uint32_t                                :  5;
+            uint32_t                m_bPresence     :  1;   //!< Presence of this feature           
+        }                           m;
+        uint32_t                    m_nAll;
+    }                               m_Ctrl;
+
+    uint32_t                        m_nUserVal;             //!< user provided SIS value
+} dc1394_avt_csradv_sis_t;
+
+// ---------------------------------------------------------------------------
+typedef union __dc1394_avt_csradv_swfeature_union
+{
+        struct __tagCsrAdvSwFeatureCtrlElems
+        {
+            uint32_t                            : 14;
+            uint32_t            m_bBlankLED     :  1;   //!< BlankLED on/off
+            uint32_t                            :  1;
+            uint32_t                            : 14;
+            uint32_t            m_bBlankLED_Inq :  1;   //!< BlankLED inquiry
+            uint32_t            m_bPresence     :  1;   //!< Presence of this feature
+        }                       m;
+        uint32_t                m_nAll;
+} dc1394_avt_csradv_swfeature_t;
+// ---------------------------------------------------------------------------
+//
+typedef union __dc1394_avt_csradv_userprofile_union
+{
+    struct __tagCsrAdvUserProfileElems
+    {
+        uint32_t                m_nProfileID    :  4;   //!< load/save from/to profile with the id ID
+        uint32_t                                :  4;
+        uint32_t                m_nErrCode      :  4;   //!<
+        uint32_t                                :  9;
+        uint32_t                m_bSetAsDef     :  1;   //!< set Profile ID as default
+        uint32_t                m_bMemLoad      :  1;   //!< load settings
+        uint32_t                m_bMemSave      :  1;   //!< save settings
+        uint32_t                m_bBusy         :  1;   //!< load/save operation in progress
+        uint32_t                                :  5;
+        uint32_t                m_bError        :  1;   //!< load/save error
+        uint32_t                m_bPresence     :  1;   //!< Presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_userprofile_t;
+
+/**
+ *  Extended/mapped format 7 modes
+ */
+typedef struct __dc1394_avt_csradv_f7mode_mapping_struct
+{
+    union __tagCsrAdvExtdF7ModesElems
+    {
+        struct __tagCsrAdvExtdF7ModesBitElems
+        {
+            uint32_t                            : 25;
+            uint32_t            m_bOnOff        :  1;   //!< enable this feature
+            uint32_t                            :  5;
+            uint32_t            m_bPresence     :  1;   //!< presence of this feature
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_Ctrl;
+
+    uint32_t                    m_Inq[2];                 //!< available extended modes
+    uint32_t                    m_Gap3;
+                                                        //! mapped format 7 modes
+    uint32_t                    m_nMappedModes[DC1394_AVT_NUM_FORMAT7_MODES];
+} dc1394_avt_csradv_f7mode_mapping_t;
+
+/**
+ *  Advanced feature to override the maximum ISO packet size. Because we
+ *  want speed, we don't obey S100 and S200 here...
+ */
+typedef struct __dc1394_avt_csradv_max_isosize_struct
+{
+    union __tagCsrAdvMaxIsoSizeElems
+    {
+        struct __tagCsrAdvIsoSizeBitElems
+        {
+            uint32_t            m_nMaxSize      : 16;    //!< MaxBytePerPacket for format 7 modes
+            uint32_t                            :  8;
+            uint32_t            m_bSet2Max      :  1;    //!< set to maximum supported packet size
+            uint32_t            m_bOnOff        :  1;    //!< enable MaxBytePerPacket
+            uint32_t                            :  5;
+            uint32_t            m_bPresence     :  1;    //!< presence of this feature
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_S400,                    //!< ISO packet size S400
+                                m_S800,                    //!< ISO packet size S800
+                                m_S1600,
+                                m_S3200;
+} dc1394_avt_csradv_max_isosize_t;
+
+/**
+ *  Advanced parameter update control
+ *  This feature controls the update behaviour of the camera between the
+ *  host and the uC and also between the uC and the FPGA. It controls when
+ *  and how new parameters become active
+ */
+typedef union __dc1394_avt_csradv_paramupd_timing_union
+{
+    struct __tagCsrAdvParamUpdTimingElems
+    {
+        uint32_t                m_nFpgaUpdMode  :  8;   //!< FPGA parameter update behaviour
+        uint32_t                                : 17;
+        uint32_t                m_bUpdActive    :  1;   //!< indicates an parameter update cycle
+        uint32_t                                :  5;
+        uint32_t                m_bPresence     :  1;   //!< Presence of this feature
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_paramupd_timing_t;
+
+/**
+ *  Advanced white balance - extends the standard white balance feature to 4
+ *  independent color controllers
+ */
+typedef struct __dc1394_avt_csradv_whitebal_struct
+{
+    // advanced white balance inquiry
+    dc1394_avt_csr_whitebal_inq_t           m_Inq;
+
+    // independent color controllers
+    union __tagAdvWhiteBal1
+    {
+        struct __tagAdvWhiteBal1Elems
+        {
+            uint32_t            m_nPxga1        : 12;   //!< PXGA 1 or 3
+            uint32_t            m_nPxga2        : 12;   //!< PXGA 2 or 4
+            uint32_t            m_bAMMode       :  1;   //!< auto mode on/off
+            uint32_t                            :  1;
+            uint32_t            m_bOnePush      :  1;   //!< one push operation
+            uint32_t                            :  3;
+            uint32_t                            :  1;
+            uint32_t            m_bPresence     :  1;   //!< feature presence
+        }                       m;
+        uint32_t                m_nAll;
+    }                           m_WhiteBal12,           //!< white balance control PXGA 1+2
+                                m_WhiteBal34;           //!< white balance control PXGA 3+4
+} dc1394_avt_csradv_whitebal_t;
+
+/**
+ *  Advanced parameter list info
+ *  @remarks GPDATA_BUFFER and PARAMLIST_BUFFER share the same memory!
+ */
+typedef union __dc1394_avt_csradv_paramlist_info_union
+{
+    struct __tagCsrAdvParamListInfoElems
+    {
+        uint32_t                m_nSize         : 16;   //!< size of the parameter list buffer in bytes
+        uint32_t                m_nLastItem     :  8;   //!< position of last processed item
+        uint32_t                m_nErrorCode    :  4;   //!< parameter list operation errors
+        uint32_t                                :  3;
+        uint32_t                m_bPresence     :  1;   //!< feature presence
+    }                           m;
+    uint32_t                    m_nAll;
+} dc1394_avt_csradv_paramlist_info_t;
+
+#define DC1394_AVT_PARAMLIST_ADDRESS_ERR     1       //!< unknown CSR address
+#define DC1394_AVT_PARAMLIST_CSR_NWR_ERR     2       //!< CSR not writable
+#define DC1394_AVT_PARAMLIST_CSR_VOID_ERR    3       //!< CSR not allowed here
+#define DC1394_AVT_PARAMLIST_CSR_NMEM_ERR    4       //!< CSR has not writable memory
+
+
+
+
+
+#endif /// #ifndef  __CSR_STRUCTS_ADV_H
diff -Nur libdc1394-2.1.2/dc1394/vendor/avt.h libdc1394_avt-2.1.2/dc1394/vendor/avt.h
--- libdc1394-2.1.2/dc1394/vendor/avt.h	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/dc1394/vendor/avt.h	2010-01-12 16:29:51.000000000 +0100
@@ -7,6 +7,8 @@
  *
  * Copyright (C) 2005 Inria Sophia-Antipolis
  *
+ * Additions by Allied Vision Technologies GmbH.
+ *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
@@ -29,11 +31,353 @@
 #include <dc1394/types.h>
 #include <dc1394/log.h>
 
+
 /*! \file dc1394/vendor/avt.h
-    \brief No docs yet
+    \brief Definition of AVT-specific features
 
     More details soon
 */
+
+#define DC1394_AVT_VENDOR_ID 0xa47
+
+/* defines used for dc1394_avt_get_io, dc1394_avt_set_io, dc1394_avt_get_io_pwmout... */
+#define DC1394_AVT_IO_INP_CTRL1                     0x300U
+#define DC1394_AVT_IO_INP_CTRL2                     0x304U
+#define DC1394_AVT_IO_INP_CTRL3                     0x308U
+#define DC1394_AVT_IO_INP_CTRL4                     0x30CU
+#define DC1394_AVT_IO_INP_CTRL5                     0x310U
+#define DC1394_AVT_IO_INP_CTRL6                     0x314U
+#define DC1394_AVT_IO_INP_CTRL7                     0x318U
+#define DC1394_AVT_IO_INP_CTRL8                     0x31CU
+#define DC1394_AVT_IO_OUTP_CTRL1                    0x320U
+#define DC1394_AVT_IO_OUTP_CTRL2                    0x324U
+#define DC1394_AVT_IO_OUTP_CTRL3                    0x328U
+#define DC1394_AVT_IO_OUTP_CTRL4                    0x32CU
+#define DC1394_AVT_IO_OUTP_CTRL5                    0x330U
+#define DC1394_AVT_IO_OUTP_CTRL6                    0x334U
+#define DC1394_AVT_IO_OUTP_CTRL7                    0x338U
+#define DC1394_AVT_IO_OUTP_CTRL8                    0x33CU
+#define DC1394_AVT_IO_OUTP_PWM_CTRL1                0x800U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL2                0x804U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL3                0x808U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL4                0x80CU
+#define DC1394_AVT_IO_OUTP_PWM_CTRL5                0x810U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL6                0x814U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL7                0x818U
+#define DC1394_AVT_IO_OUTP_PWM_CTRL8                0x81CU
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL1            0x840U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL2            0x850U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL3            0x860U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL4            0x870U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL5            0x880U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL6            0x890U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL7            0x8A0U
+#define DC1394_AVT_IO_INP_DEBOUNCE_CTRL8            0x8B0U
+
+
+/**
+ * Enumeration of AVT camera family IDs. Value is stored in bits 24-31 of the cameras serial number.
+ */
+typedef enum {
+    DC1394_AVT_FAMILY_DOLPHIN_OLD= 0,
+    DC1394_AVT_FAMILY_MARLIN_OLD= 1,
+    DC1394_AVT_FAMILY_ZK_1_5_8_OLD= 2,
+    DC1394_AVT_FAMILY_OSCAR_OLD= 3,
+    DC1394_AVT_FAMILY_MARLIN_2_OLD= 4,
+    DC1394_AVT_FAMILY_GUPPY_OLD= 5,
+    DC1394_AVT_FAMILY_PIKE_OLD= 6,
+    DC1394_AVT_FAMILY_DOLPHIN= 10,
+    DC1394_AVT_FAMILY_MARLIN= 11,
+    DC1394_AVT_FAMILY_ZK_1_5_8= 12,
+    DC1394_AVT_FAMILY_OSCAR= 13,
+    DC1394_AVT_FAMILY_MARLIN_2= 14,
+    DC1394_AVT_FAMILY_GUPPY= 15,
+    DC1394_AVT_FAMILY_PIKE= 16,
+    DC1394_AVT_FAMILY_STINGRAY= 17,
+    DC1394_AVT_FAMILY_GUPPYPRO= 18
+} dc1394_avt_family_t;
+
+/**
+ * Enumeration of AVT camera IDs, as returned by dc1394_avt_get_version.
+ */
+typedef enum {
+    /* Dolphin Family */
+    DC1394_AVT_CAMERA_ID_DF145B= 1,
+    DC1394_AVT_CAMERA_ID_DF145C= 2,
+    DC1394_AVT_CAMERA_ID_DF201B= 3,
+    DC1394_AVT_CAMERA_ID_DF201C= 4,
+    DC1394_AVT_CAMERA_ID_DF145B_1= 5,
+    DC1394_AVT_CAMERA_ID_DF145C_1= 6,
+    DC1394_AVT_CAMERA_ID_DF201B_1= 7,
+    DC1394_AVT_CAMERA_ID_DF201C_1= 8,
+
+    /* Marlin I Family */
+    DC1394_AVT_CAMERA_ID_MF033B= 9,
+    DC1394_AVT_CAMERA_ID_MF033C= 10,
+    DC1394_AVT_CAMERA_ID_MF046B= 11,
+    DC1394_AVT_CAMERA_ID_MF046C= 12,
+    DC1394_AVT_CAMERA_ID_MF080B= 13,
+    DC1394_AVT_CAMERA_ID_MF080C= 14,
+    DC1394_AVT_CAMERA_ID_MF145B= 15,
+    DC1394_AVT_CAMERA_ID_MF145C= 16,
+    DC1394_AVT_CAMERA_ID_MF131B= 17,
+    DC1394_AVT_CAMERA_ID_MF131C= 18,
+    DC1394_AVT_CAMERA_ID_MF145B3= 19,
+    DC1394_AVT_CAMERA_ID_MF145C3= 20,
+
+    /* Marlin II Family */
+    DC1394_AVT_CAMERA_ID_M2F033B= 21,
+    DC1394_AVT_CAMERA_ID_M2F033C= 22,
+    DC1394_AVT_CAMERA_ID_M2F046B= 23,
+    DC1394_AVT_CAMERA_ID_M2F046C= 24,
+    DC1394_AVT_CAMERA_ID_M2F080B= 25,
+    DC1394_AVT_CAMERA_ID_M2F080C= 26,
+    DC1394_AVT_CAMERA_ID_M2F145B= 27,
+    DC1394_AVT_CAMERA_ID_M2F145C= 28,
+    DC1394_AVT_CAMERA_ID_M2F145B3= 31,
+    DC1394_AVT_CAMERA_ID_M2F145C3= 32,
+
+    /* Oscar Family */
+    DC1394_AVT_CAMERA_ID_OF320B= 37,
+    DC1394_AVT_CAMERA_ID_OF320C= 38,
+    DC1394_AVT_CAMERA_ID_OF510B= 39,
+    DC1394_AVT_CAMERA_ID_OF510C= 40,
+    DC1394_AVT_CAMERA_ID_OF810B= 41,
+    DC1394_AVT_CAMERA_ID_OF810C= 42,
+
+    /* Marlin II Family */
+    DC1394_AVT_CAMERA_ID_M2F080B_30FPS= 43,
+    DC1394_AVT_CAMERA_ID_M2F080C_30FPS= 44,
+    DC1394_AVT_CAMERA_ID_M2F145B4= 45,
+    DC1394_AVT_CAMERA_ID_M2F145C4= 46,
+    DC1394_AVT_CAMERA_ID_M2F201B= 47,
+    DC1394_AVT_CAMERA_ID_M2F201C= 48,
+    DC1394_AVT_CAMERA_ID_M2F146B= 49,
+    DC1394_AVT_CAMERA_ID_M2F146C= 50,
+
+    /* Pike Family */
+    DC1394_AVT_CAMERA_ID_PF032B= 101,
+    DC1394_AVT_CAMERA_ID_PF032C= 102,
+    DC1394_AVT_CAMERA_ID_PF100B= 103,
+    DC1394_AVT_CAMERA_ID_PF100C= 104,
+    DC1394_AVT_CAMERA_ID_PF145B= 105,
+    DC1394_AVT_CAMERA_ID_PF145C= 106,
+    DC1394_AVT_CAMERA_ID_PF201B= 107,
+    DC1394_AVT_CAMERA_ID_PF201C= 108,
+    DC1394_AVT_CAMERA_ID_PF411B= 109,
+    DC1394_AVT_CAMERA_ID_PF411C= 110,
+    DC1394_AVT_CAMERA_ID_PF421B= 111,
+    DC1394_AVT_CAMERA_ID_PF421C= 112,
+    DC1394_AVT_CAMERA_ID_PF210BM= 113,
+    DC1394_AVT_CAMERA_ID_PF210CM= 114,
+    DC1394_AVT_CAMERA_ID_PF145B_15= 115,
+    DC1394_AVT_CAMERA_ID_PF145C_15= 116,
+    DC1394_AVT_CAMERA_ID_PF505B= 117,
+    DC1394_AVT_CAMERA_ID_PF505C= 118,
+    DC1394_AVT_CAMERA_ID_PF1100B= 119,
+    DC1394_AVT_CAMERA_ID_PF1100C= 120,
+    DC1394_AVT_CAMERA_ID_PF422B= 121,
+    DC1394_AVT_CAMERA_ID_PF422C= 122,
+    DC1394_AVT_CAMERA_ID_PF1102B= 123,
+    DC1394_AVT_CAMERA_ID_PF1102C= 124,
+    DC1394_AVT_CAMERA_ID_PF1600B= 125,
+    DC1394_AVT_CAMERA_ID_PF1600C= 126,
+
+    /* Guppy Family */
+    DC1394_AVT_CAMERA_ID_GF033B= 201,
+    DC1394_AVT_CAMERA_ID_GF033C= 202,
+    DC1394_AVT_CAMERA_ID_GF036B= 203,
+    DC1394_AVT_CAMERA_ID_GF036C= 204,
+    DC1394_AVT_CAMERA_ID_GF046B= 205,
+    DC1394_AVT_CAMERA_ID_GF046C= 206,
+    DC1394_AVT_CAMERA_ID_GF080B= 207,
+    DC1394_AVT_CAMERA_ID_GF080C= 208,
+    DC1394_AVT_CAMERA_ID_GF146B= 209,
+    DC1394_AVT_CAMERA_ID_GF146C= 210,
+    DC1394_AVT_CAMERA_ID_GF033B_GP1= 211,
+    DC1394_AVT_CAMERA_ID_GF033B_BL= 213,
+    DC1394_AVT_CAMERA_ID_GF033C_BL= 214,
+    DC1394_AVT_CAMERA_ID_GF025B= 215,
+    DC1394_AVT_CAMERA_ID_GF025C= 216,
+    DC1394_AVT_CAMERA_ID_GF029B= 217,
+    DC1394_AVT_CAMERA_ID_GF029C= 218,
+    DC1394_AVT_CAMERA_ID_GF038B= 219,
+    DC1394_AVT_CAMERA_ID_GF038C= 220,
+    DC1394_AVT_CAMERA_ID_GF038B_NIR= 221,
+    DC1394_AVT_CAMERA_ID_GF038C_NIR= 222,
+    DC1394_AVT_CAMERA_ID_GF044B_NIR= 223,
+    DC1394_AVT_CAMERA_ID_GF044C_NIR= 224,
+    DC1394_AVT_CAMERA_ID_GF080B_BL= 225,
+    DC1394_AVT_CAMERA_ID_GF080C_BL= 226,
+    DC1394_AVT_CAMERA_ID_GF044B= 227,
+    DC1394_AVT_CAMERA_ID_GF044C= 228,
+    DC1394_AVT_CAMERA_ID_OC030B_BL= 229,
+    DC1394_AVT_CAMERA_ID_OC030C_BL= 230,
+    DC1394_AVT_CAMERA_ID_GP145B_BL= 231,
+    DC1394_AVT_CAMERA_ID_GP145C_BL= 232,
+    DC1394_AVT_CAMERA_ID_GF503B= 233,
+    DC1394_AVT_CAMERA_ID_GF503C= 234,
+
+    /* Stingray Family */
+    DC1394_AVT_CAMERA_ID_SF033B= 401,
+    DC1394_AVT_CAMERA_ID_SF033C= 402,
+    DC1394_AVT_CAMERA_ID_SF03XB= 403,
+    DC1394_AVT_CAMERA_ID_SF03XC= 404,
+    DC1394_AVT_CAMERA_ID_SF046B= 405,
+    DC1394_AVT_CAMERA_ID_SF046C= 406,
+    DC1394_AVT_CAMERA_ID_SF080B= 407,
+    DC1394_AVT_CAMERA_ID_SF080C= 408,
+    DC1394_AVT_CAMERA_ID_SF125B= 409,
+    DC1394_AVT_CAMERA_ID_SF125C= 410,
+    DC1394_AVT_CAMERA_ID_SF131B= 411,
+    DC1394_AVT_CAMERA_ID_SF131C= 412,
+    DC1394_AVT_CAMERA_ID_SF145B= 413,
+    DC1394_AVT_CAMERA_ID_SF145C= 414,
+    DC1394_AVT_CAMERA_ID_SF146B= 415,
+    DC1394_AVT_CAMERA_ID_SF146C= 416,
+    DC1394_AVT_CAMERA_ID_SF201B= 417,
+    DC1394_AVT_CAMERA_ID_SF201C= 418,
+    DC1394_AVT_CAMERA_ID_SF505B= 419,
+    DC1394_AVT_CAMERA_ID_SF505C= 420,
+    DC1394_AVT_CAMERA_ID_SF145B_30= 421,
+    DC1394_AVT_CAMERA_ID_SF145C_30= 422,
+    DC1394_AVT_CAMERA_ID_SF504B= 423,
+    DC1394_AVT_CAMERA_ID_SF504C= 424,
+    DC1394_AVT_CAMERA_ID_SF145_25_CL= 425,
+    DC1394_AVT_CAMERA_ID_SF146_ICM1= 427,
+    DC1394_AVT_CAMERA_ID_SF146_ICC1= 428,
+    DC1394_AVT_CAMERA_ID_SF201B_CSO= 429,
+    DC1394_AVT_CAMERA_ID_SF201C_CSO= 430,
+    DC1394_AVT_CAMERA_ID_SF504B_AB= 431,
+    DC1394_AVT_CAMERA_ID_SF504C_AB= 432,
+    DC1394_AVT_CAMERA_ID_SF504B_FF= 433,
+    DC1394_AVT_CAMERA_ID_SF504C_FF= 434,
+
+    /* Guppy Pro Family */
+    DC1394_AVT_CAMERA_ID_GPF031B= 501,
+    DC1394_AVT_CAMERA_ID_GPF031C= 502,
+    DC1394_AVT_CAMERA_ID_GPF033B= 503,
+    DC1394_AVT_CAMERA_ID_GPF033C= 504,
+    DC1394_AVT_CAMERA_ID_GPF046B= 507,
+    DC1394_AVT_CAMERA_ID_GPF046C= 508,
+    DC1394_AVT_CAMERA_ID_GPF080B= 509,
+    DC1394_AVT_CAMERA_ID_GPF080C= 510,
+    DC1394_AVT_CAMERA_ID_GPF125B= 511,
+    DC1394_AVT_CAMERA_ID_GPF125C= 512,
+    DC1394_AVT_CAMERA_ID_GPF201B= 517,
+    DC1394_AVT_CAMERA_ID_GPF201C= 518,
+    DC1394_AVT_CAMERA_ID_GPF503B= 519,
+    DC1394_AVT_CAMERA_ID_GPF503C= 520,
+    DC1394_AVT_CAMERA_ID_GPF504B= 521,
+    DC1394_AVT_CAMERA_ID_GPF504C= 522
+} dc1394_avt_camera_id_t;
+
+/**
+ * Inquiry of available advanced features - This struct is intended to be used as a replacement for dc1394_avt_adv_feature_info_t.
+ * For initialization see dc1394_avt_get_smart_feature_inquiry().
+ */
+typedef struct __dc1394_avt_smart_feature_info_struct
+{
+    uint32_t        Size;
+
+    /* Camera capabilities provided as user information. */
+    dc1394bool_t    MaxResolution;
+    dc1394bool_t    TimeBase;
+    dc1394bool_t    ExtdShutter;
+    dc1394bool_t    TestImage;
+    dc1394bool_t    FrameCounter;
+    dc1394bool_t    Sequences;
+    dc1394bool_t    VersionInfo;
+    dc1394bool_t    Lookup_Tables;
+    dc1394bool_t    Shading;
+    dc1394bool_t    DeferredTransport;
+    dc1394bool_t    HDR_Mode;
+    dc1394bool_t    DSNU;
+    dc1394bool_t    BlemishCorrection;
+    dc1394bool_t    TriggerDelay;
+    dc1394bool_t    MirrorImage;
+    dc1394bool_t    SoftReset;
+    dc1394bool_t    HSNR;
+    dc1394bool_t    ColorCorrection;
+    dc1394bool_t    ColorAvg;
+    dc1394bool_t    SIS;
+    dc1394bool_t    UserProfiles;
+    dc1394bool_t    TriggerCounter;
+    dc1394bool_t    ParamListBuffer;
+    dc1394bool_t    GP_Buffer;
+
+    dc1394bool_t    Input_1;
+    dc1394bool_t    Input_2;
+    dc1394bool_t    Input_3;
+    dc1394bool_t    Input_4;
+    dc1394bool_t    Input_5;
+    dc1394bool_t    Input_6;
+    dc1394bool_t    Input_7;
+    dc1394bool_t    Input_8;
+    dc1394bool_t    Output_1;
+    dc1394bool_t    Output_2;
+    dc1394bool_t    Output_3;
+    dc1394bool_t    Output_4;
+    dc1394bool_t    Output_5;
+    dc1394bool_t    Output_6;
+    dc1394bool_t    Output_7;
+    dc1394bool_t    Output_8;
+    dc1394bool_t    IntEnaDelay;
+    dc1394bool_t    IncDecoder;
+    dc1394bool_t    Output_1_PWM;
+    dc1394bool_t    Output_2_PWM;
+    dc1394bool_t    Output_3_PWM;
+    dc1394bool_t    Output_4_PWM;
+    dc1394bool_t    Output_5_PWM;
+    dc1394bool_t    Output_6_PWM;
+    dc1394bool_t    Output_7_PWM;
+    dc1394bool_t    Output_8_PWM;
+
+    dc1394bool_t    CameraStatus;
+    dc1394bool_t    MaxIsoSize_S400;
+    dc1394bool_t    MaxIsoSize_S800;
+    dc1394bool_t    ParamUpdTiming;
+    dc1394bool_t    F7ModeMapping;
+    dc1394bool_t    AutoShutter;
+    dc1394bool_t    AutoGain;
+    dc1394bool_t    AutoFunctionAOI;
+    dc1394bool_t    SequenceStep;
+    dc1394bool_t    LowNoiseBinning;
+    dc1394bool_t    GlobalResetReleaseShutter;
+    dc1394bool_t    DefectPixelCorrection;
+    dc1394bool_t    SWFeatureControl;
+    dc1394bool_t    LedBlanking;
+    dc1394bool_t    InputDebounce_1;
+    dc1394bool_t    InputDebounce_2;
+    dc1394bool_t    InputDebounce_3;
+    dc1394bool_t    InputDebounce_4;
+    dc1394bool_t    InputDebounce_5;
+    dc1394bool_t    InputDebounce_6;
+    dc1394bool_t    InputDebounce_7;
+    dc1394bool_t    InputDebounce_8;
+
+    dc1394bool_t    HDRPike;
+    dc1394bool_t    ChannelAdjustGain;
+    dc1394bool_t    LowSmear;
+    dc1394bool_t    AdvWhiteBal;
+    dc1394bool_t    ChannelAdjustOffset;
+
+    dc1394bool_t    reserved[64];
+
+    /* Internal information used by libdc functions. */
+    struct __tagCsrAdvInquiryHidden
+    {
+        uint32_t Inq1;
+        uint32_t Inq2;
+        uint32_t Inq3;
+        uint32_t Inq4;
+    } Internal;
+} dc1394_avt_smart_feature_info_t;
+
+/**
+ * Inquiry of available advanced features - This struct is provided for backwards compatibility. New code
+ * should use dc1394_avt_adv_function_inquiry_t instead.
+ */
 typedef struct __dc1394_avt_adv_feature_info_struct
 {
     uint32_t feature_id;
@@ -93,9 +437,60 @@
 } dc1394_avt_adv_feature_info_t;
 
 
+/**
+ * SIS data structure
+ * See also dc1394_avt_set_sis, dc1394_avt_get_sis_data_inquiry and dc1394_avt_get_sis_data.
+ */
+typedef struct __dc1394_avt_sis_data_struct
+{
+    union
+    {
+        struct
+        {
+            uint32_t    Offset : 12;       //!< elapsed time within the current bus cycle, unit 40.69 ns (range 0-3071)
+            uint32_t    Cycles : 13;       //!< elapsed time in firewire bus cycles, unit 125 us, will be reset every second (range 0-7999)
+            uint32_t    Seconds: 7;        //!< elapsed time in seconds
+        }m;
+        uint32_t m_all;
+    } CycleTime;
+    uint32_t     FrameCounter;         //!< frame number
+    uint32_t     TriggerCounter;       //!< number of detected trigger events
+    uint16_t     AOILeft;              //!< AOI left position
+    uint16_t     AOITop;               //!< AOI top position
+    uint16_t     AOIWidth;             //!< AOI width
+    uint16_t     AOIHeight;            //!< AOI height
+    uint32_t     Shutter;              //!< shutter setting
+    uint16_t     Gain;                 //!< gain setting
+    uint16_t     Reserved0;            //!< reserved for future use
+    uint8_t      OutputState[4];       //!< output pin states - idle:0 active:255
+    uint8_t      InputState[2];        //!< input pin states - idle:0 active:255
+    uint8_t      Reserved1[2];         //!< reserved for future use
+    uint8_t      SequenceIndex;        //!< sequence position (sequence mode)
+    uint8_t      Reserved2a;           //!< reserved for future use
+    uint8_t      ColorCoding;          //!< IIDC color coding
+    uint8_t      Reserved2b;           //!< reserved for future use
+    uint32_t     SerialNumber;         //!< camera serial number
+    uint32_t     UserValue;            //!< user defined value
+} dc1394_avt_sis_data;
+
+/*
+ * Pixel Position for Defect Pixel Correction
+ * See also dc1394_avt_set_dpc, dc1394_avt_read_dpc_data and dc1394_avt_write_dpc_data
+ */
+typedef union __dc1394_avt_dpc_pixel_position_union
+{
+    struct
+    {
+        uint32_t    x : 16;       //!< Defect Pixel X-Coordinate
+        uint32_t    y : 16;       //!< Defect Pixel Y-Coordinate
+    }m;
+    uint32_t m_all;
+} dc1394_avt_dpc_pixel_position;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
+
 /**
  * Retrieve the firmware version, FPGA version and the camera ID
  */
@@ -105,21 +500,45 @@
                                      uint32_t *Camera_ID,
                                      uint32_t *FPGA_Version);
 
-
+/**
+ * Adjust the frame's color code (in some situations where raw is declared as mono).
+ * It is safe to call this function for any received frame.
+ */
+dc1394error_t dc1394_avt_adjust_frames(uint32_t Camera_ID, dc1394video_frame_t *frame);
 
 /**
- * Retrieve the supported features
+ * Retrieve a list with supported features
+ * This function is provided for backwards compatibility. New code should call 
+ * dc1394_avt_get_smart_feature_inquiry instead.
  */
 dc1394error_t dc1394_avt_get_advanced_feature_inquiry(dc1394camera_t *camera,
                                                       dc1394_avt_adv_feature_info_t *adv_feature);
 
 /**
- * Print the supported features requested
+ * Retrieve a list with supported features
+ * Parameter 'size' is expected to reflect the size of struct smart_feature in bytes.
+ * It is recommended to pass 'sizeof(dc1394_avt_smart_feature_inquiry_t)' as size.
+ */
+dc1394error_t dc1394_avt_get_smart_feature_inquiry(dc1394camera_t *camera,
+                                                   dc1394_avt_smart_feature_info_t *smart_feature,
+                                                   int size );
+
+/**
+ * Print the list of supported features
+ * See also dc1394_avt_get_advanced_feature_inquiry
  */
 dc1394error_t dc1394_avt_print_advanced_feature(dc1394_avt_adv_feature_info_t *adv_feature);
 
 /**
- * Retrieve if shading is on and the number of frames used to compute the shading reference frame
+ * Print the list of supported features
+ * See also dc1394_avt_get_smart_feature_inquiry
+ */
+dc1394error_t dc1394_avt_print_smart_features(dc1394_avt_smart_feature_info_t *adv_feature);
+
+/**
+ * Get Shading Correction settings.
+ * This function is provided for backwards compatibility - new code
+ * should call dc1394_avt_get_shading_correction instead.
  */
 dc1394error_t dc1394_avt_get_shading(dc1394camera_t *camera,
                                      dc1394bool_t *on_off,
@@ -127,14 +546,40 @@
                                      dc1394bool_t *show, uint32_t *frame_nb);
 
 /**
- * Set the shading to on/off and the number of frames used to compute the shading reference frame
+ * Get Shading Correction settings
+ */
+dc1394error_t dc1394_avt_get_shading_correction(dc1394camera_t *camera,
+                                                dc1394switch_t *on_off,
+                                                dc1394bool_t *build_err,
+                                                dc1394switch_t *show, 
+                                                uint32_t *frame_nb,
+                                                uint32_t *mem_channel,
+                                                uint32_t *mem_channel_err);
+
+/**
+ * Set Shading Correction feature
+ * This function is provided for backwards compatibility - new code
+ * should call dc1394_avt_set_shading_correction instead.
  */
 dc1394error_t dc1394_avt_set_shading(dc1394camera_t *camera,
                                      dc1394bool_t on_off, dc1394bool_t compute,
                                      dc1394bool_t show, uint32_t frame_nb);
 
 /**
- * Retrieve write and read access mode of the shading reference frame
+ * Set Shading Correction feature
+ */
+dc1394error_t dc1394_avt_set_shading_correction(dc1394camera_t *camera,
+                                                dc1394switch_t on_off, 
+                                                dc1394switch_t compute,
+                                                dc1394switch_t show, 
+                                                uint32_t frame_nb,
+                                                uint32_t mem_channel,
+                                                dc1394switch_t mem_clear,
+                                                dc1394switch_t mem_load,
+                                                dc1394switch_t mem_save);
+
+/**
+ * Get the current access mode (none/read/write) for Shading Correction image
  */
 dc1394error_t dc1394_avt_get_shading_mem_ctrl(dc1394camera_t *camera,
                                               dc1394bool_t *en_write,
@@ -142,7 +587,7 @@
                                               uint32_t *addroffset);
 
 /**
- * Set write and read access mode of the shading reference frame
+ * Set access mode (none/read/write) for Shading Correction image
  */
 dc1394error_t dc1394_avt_set_shading_mem_ctrl(dc1394camera_t *camera,
                                               dc1394bool_t en_write,
@@ -150,13 +595,24 @@
                                               uint32_t addroffset);
 
 /**
- * Retrieve the max size of a shading image
+ * Retrieve the max size of a Shading Correction image
+ * This function is provided for backwards compatibility - new code
+ * should call dc1394_avt_get_shading_correction_info instead.
  */
 dc1394error_t dc1394_avt_get_shading_info(dc1394camera_t *camera,
                                           uint32_t *MaxImageSize);
 
 /**
- * Retrieve if on/off, the nb of kneepoints used and the kneepoints values
+ * Retrieve the max size of a Shading Correction image and the number of 
+ * supported memory channels to store shading images inside the camera.
+ */
+dc1394error_t dc1394_avt_get_shading_correction_info(dc1394camera_t *camera,
+                                                     uint32_t *MaxImageSize,
+                                                     uint32_t *MemChannelCount);
+
+/**
+ * Get HDR mode (multiple slope) configuration
+ * (on/off, the nb of kneepoints used and kneepoints values)
  */
 dc1394error_t dc1394_avt_get_multiple_slope(dc1394camera_t *camera,
                                             dc1394bool_t *on_off,
@@ -166,7 +622,8 @@
                                             uint32_t *kneepoint3);
 
 /**
- * Set on/off, the nb of kneepoints to use and the kneepoints values
+ * Set HDR mode (multiple slope) configuration
+ * (on/off, the nb of kneepoints used and kneepoints values)
  */
 dc1394error_t dc1394_avt_set_multiple_slope(dc1394camera_t *camera,
                                             dc1394bool_t on_off,
@@ -176,119 +633,184 @@
                                             uint32_t kneepoint3);
 
 /**
- * Get the timebase value with an Id. See Manual for correspondance
+ * Get the timebase used for 'shutter' feature.
+ * Possible values: 
+ * 0:    1us 
+ * 1:    2us
+ * 2:    5us
+ * 3:   10us
+ * 4:   20us
+ * 5:   50us
+ * 6:  100us
+ * 7:  200us
+ * 8:  500us
+ * 9: 1000us
  */
 dc1394error_t dc1394_avt_get_timebase(dc1394camera_t *camera,
                                       uint32_t *timebase_id);
 
 /**
- * Set the timebase value with an Id. See Manual for correspondance
+ * Set the timebase used for 'shutter' feature. See dc1394_avt_get_timebase for possible values.
  */
 dc1394error_t dc1394_avt_set_timebase(dc1394camera_t *camera,
                                       uint32_t timebase_id);
 
 /**
- * Get the extented shutter value in us
+ * Get the Extented Shutter value in us
  */
 dc1394error_t dc1394_avt_get_extented_shutter(dc1394camera_t *camera,
                                               uint32_t *timebase_id);
 
 /**
- * Set the extented shutter value in us
+ * Set the Extented Shutter value in us
  */
 dc1394error_t dc1394_avt_set_extented_shutter(dc1394camera_t *camera,
                                               uint32_t timebase_id);
 
 /**
- * Get the Max reachable resolution
+ * Get the Max achievable resolution
  */
 dc1394error_t dc1394_avt_get_MaxResolution(dc1394camera_t *camera,
                                            uint32_t *MaxHeight,
                                            uint32_t *MaxWidth);
 
 /**
- * Get min and max shutter values for autoshutter
+ * Get min and max shutter values for Autoshutter
  */
 dc1394error_t dc1394_avt_get_auto_shutter(dc1394camera_t *camera,
                                           uint32_t *MinValue,
                                           uint32_t *MaxValue);
 
 /**
- * Set min and max shutter values for autoshutter
+ * Set min and max shutter values for Autoshutter
  */
 dc1394error_t dc1394_avt_set_auto_shutter(dc1394camera_t *camera,
                                           uint32_t MinValue,
                                           uint32_t MaxValue);
 
 /**
- * Get min and max gain values for autogain
+ * Get min and max gain values for Autogain
  */
 dc1394error_t dc1394_avt_get_auto_gain(dc1394camera_t *camera,
                                        uint32_t *MinValue,
                                        uint32_t *MaxValue);
 
 /**
- * Set min and max gain values for autogain
+ * Set min and max gain values for Autogain
  */
 dc1394error_t dc1394_avt_set_auto_gain(dc1394camera_t *camera,
                                        uint32_t MinValue,
                                        uint32_t MaxValue);
 
 /**
- * Get if trigger delay on and the trigger delay
+ * Get Trigger Delay configuration (on/off and the actual delay)
  */
 dc1394error_t dc1394_avt_get_trigger_delay(dc1394camera_t *camera,
                                            dc1394bool_t *on_off,
                                            uint32_t *DelayTime);
 
 /**
- * Set trigger delay on/off  and the trigger delay value
+ * Set Trigger Delay configuration (on/off and the actual delay)
  */
 dc1394error_t dc1394_avt_set_trigger_delay(dc1394camera_t *camera,
                                            dc1394bool_t on_off,
                                            uint32_t DelayTime);
 
 /**
- * Get mirror mode
+ * Get 'Mirror Image' configuration (horizontal)
  */
 dc1394error_t dc1394_avt_get_mirror(dc1394camera_t *camera,
                                     dc1394bool_t *on_off);
 
 /**
- * Set mirror mode
+ * Set 'Mirror Image' configuration (horizontal)
  */
 dc1394error_t dc1394_avt_set_mirror(dc1394camera_t *camera,
                                     dc1394bool_t on_off);
 
 /**
- * Get DSNU mode and num of frames used for computing  dsnu correction
+ * Get DSNU mode and num of frames used for correction data computation.
+ * This function is provided for backwards compatibility - new code
+ * should call dc1394_avt_get_dsnu_correction instead.
  */
 dc1394error_t dc1394_avt_get_dsnu(dc1394camera_t *camera,
                                   dc1394bool_t *on_off,
                                   uint32_t *frame_nb);
 
 /**
- * Set DSNU mode, number of frames used for computing and launch the the computation of the dsnu frame
+ * Get DSNU correction configuration and error status of the last correction data computation.
+ */
+dc1394error_t dc1394_avt_get_dsnu_correction(dc1394camera_t *camera,
+                                             dc1394switch_t *on_off,
+                                             dc1394bool_t   *build_error,
+                                             uint32_t       *frame_nb,
+                                             dc1394switch_t *show_image);
+
+/**
+ * Set DSNU mode, number of frames used for correction data computation and launch the the computation of the dsnu frame
+ * This function is provided for backwards compatibility - new code should call 
+ * dc1394_avt_set_dsnu_correction instead.
  */
 dc1394error_t dc1394_avt_set_dsnu(dc1394camera_t *camera,
                                   dc1394bool_t on_off, dc1394bool_t compute,
                                   uint32_t frame_nb);
 
 /**
- * Get Blemish mode and num of frames used for computing the correction
+ * Configure DSNU correction.
+ * ( Enable/Disable, number of frames used for correction data computation, launch the computation of correction data,
+ *   enable show_image to receive correction data instead of images, load or save data from/to flash )
+ */
+dc1394error_t dc1394_avt_set_dsnu_correction(dc1394camera_t *camera,
+                                             dc1394switch_t on_off, 
+                                             dc1394switch_t compute_image,
+                                             uint32_t       frame_nb,
+                                             dc1394switch_t show_image,
+                                             dc1394switch_t load_image,
+                                             dc1394switch_t save_image);
+
+/**
+ * Get Blemish mode and num of frames used for correction data computation
+ * This function is provided for backwards compatibility - new code
+ * should call dc1394_avt_get_blemish_correction instead.
  */
 dc1394error_t dc1394_avt_get_blemish(dc1394camera_t *camera,
                                      dc1394bool_t *on_off, uint32_t *frame_nb);
 
 /**
- * Set Blemish mode, num of frames used for computing and launch the the computation of the blemish correction
+ * Get Blemish Correction configuration and error status of the last correction data computation
+ */
+dc1394error_t dc1394_avt_get_blemish_correction(dc1394camera_t *camera,
+                                                dc1394switch_t *on_off,
+                                                dc1394bool_t   *build_error,
+                                                uint32_t       *frame_nb,
+                                                dc1394switch_t *show_image);
+
+/**
+ * Set Blemish mode, num of frames used for correction data computation and launch the the computation of correction data.
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_set_blemish_correction 
+ * instead.
  */
 dc1394error_t dc1394_avt_set_blemish(dc1394camera_t *camera,
                                      dc1394bool_t on_off, dc1394bool_t compute,
                                      uint32_t frame_nb);
 
 /**
- * Get the polarity, the mode, the state of the IO
+ * Configure Blemish Correction.
+ * ( On/Off, number of frames used for computation, launch computation, enable show_image to receive correction data instead of images, 
+ *   load or save data from/to flash)
+ */
+dc1394error_t dc1394_avt_set_blemish_correction(dc1394camera_t *camera,
+                                                dc1394switch_t on_off, 
+                                                dc1394switch_t compute_image,
+                                                uint32_t       frame_nb,
+                                                dc1394switch_t show_image,
+                                                dc1394switch_t load_image,
+                                                dc1394switch_t save_image);
+
+/**
+ * Get the polarity, the mode, the state of the IO.
+ * Parameter 'IO' specifies the Input-/Output Pin and should be set
+ * to DC1394_AVT_IO_INP_CTRLx or DC1394_AVT_IO_OUTP_CTRLx
  */
 dc1394error_t dc1394_avt_get_io(dc1394camera_t *camera, uint32_t IO,
                                 dc1394bool_t *polarity, uint32_t *mode,
@@ -296,30 +818,83 @@
 
 /**
  * Set the polarity, the mode and the state of the IO
+ * Parameter 'IO' specifies the Input-/Output Pin and should be set
+ * to DC1394_AVT_IO_INP_CTRLx or DC1394_AVT_IO_OUTP_CTRLx
  */
 dc1394error_t dc1394_avt_set_io(dc1394camera_t *camera,uint32_t IO,
                                 dc1394bool_t polarity, uint32_t mode,
                                 dc1394bool_t pinstate);
 
 /**
+ * Get minimum PWM (Pulse-Width Modulation) period in us.
+ * output_pin should be set to DC1394_AVT_IO_OUTP_PWM_CTRLx
+ */
+dc1394error_t dc1394_avt_get_io_pwmout_info(dc1394camera_t *camera,
+                                            uint32_t       pwm_output_pin, 
+                                            uint32_t       *min_period);
+
+/**
+ * Get timebase period and pulse width for PWM (Pulse-Width Modulation) output
+ * output_pin should be set to DC1394_AVT_IO_OUTP_PWM_CTRLx
+ */
+dc1394error_t dc1394_avt_get_io_pwmout(dc1394camera_t *camera,
+                                       uint32_t       pwm_output_pin, 
+                                       uint32_t       *period,
+                                       uint32_t       *pulse_width);
+
+/**
+ * Set period and pulse width for PWM (Pulse-Width Modulation) output.
+ * output_pin should be set to DC1394_AVT_IO_OUTP_PWM_CTRLx
+ */
+dc1394error_t dc1394_avt_set_io_pwmout(dc1394camera_t *camera,
+                                       uint32_t       pwm_output_pin, 
+                                       uint32_t       period,
+                                       uint32_t       pulse_width);
+
+/**
+ * Get valid Debounce time range for a certain input pin.
+ * debounce_inp_pin should be set to DC1394_AVT_IO_INP_DEBOUNCE_CTRLx
+ */
+dc1394error_t dc1394_avt_get_io_inp_debounce_info(dc1394camera_t *camera,
+                                                  uint32_t       debounce_inp_pin,
+                                                  uint32_t       *min_debounce_time,
+                                                  uint32_t       *max_debounce_time);
+
+/**
+ * Get Debounce time for a certain input pin.
+ * debounce_inp_pin should be set to DC1394_AVT_IO_INP_DEBOUNCE_CTRLx
+ */
+dc1394error_t dc1394_avt_get_io_inp_debounce(dc1394camera_t *camera,
+                                             uint32_t       debounce_inp_pin,
+                                             uint32_t       *debounce_time);
+
+/**
+ * Set Debounce time for a certain input pin.
+ * debounce_inp_pin should be set to DC1394_AVT_IO_INP_DEBOUNCE_CTRLx
+ */
+dc1394error_t dc1394_avt_set_io_inp_debounce(dc1394camera_t *camera,
+                                             uint32_t       debounce_inp_pin,
+                                             uint32_t       debounce_time);
+
+/**
  * Reset the bus and the fpga
  */
 dc1394error_t dc1394_avt_reset(dc1394camera_t *camera);
 
 /**
- * Get on/off and the num of the current lut loaded
+ * Get LUT (look-up table) configuration (on/off and the index of the current LUT)
  */
 dc1394error_t dc1394_avt_get_lut(dc1394camera_t *camera,
                                  dc1394bool_t *on_off, uint32_t *lutnb  );
 
 /**
- * Set on/off and the num of the current lut to loa
+ * Set LUT (look-up table) configuration (on/off and the index of the current LUT)
  */
 dc1394error_t dc1394_avt_set_lut(dc1394camera_t *camera,
                                  dc1394bool_t on_off, uint32_t lutnb);
 
 /**
- * Get access mode of a lut
+ * Get memory access mode of LUT (look-up table) data
  */
 dc1394error_t dc1394_avt_get_lut_mem_ctrl(dc1394camera_t *camera,
                                           dc1394bool_t *en_write,
@@ -327,7 +902,7 @@
                                           uint32_t *addroffset);
 
 /**
- * Set access mode of a lut
+ * Set memory access mode of LUT (look-up table) data
  */
 dc1394error_t dc1394_avt_set_lut_mem_ctrl(dc1394camera_t *camera,
                                           dc1394bool_t en_write,
@@ -335,50 +910,138 @@
                                           uint32_t addroffset);
 
 /**
- * Get num of luts present and the max size
+ * Get num of LUTs (look-up tables) present and the max size
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_get_lut_extd_info
+ * instead.
  */
 dc1394error_t dc1394_avt_get_lut_info(dc1394camera_t *camera,
                                       uint32_t *NumOfLuts, uint32_t *MaxLutSize);
 
 /**
- * Get on/off and area
+ * Get num of LUTs (look-up tables) present, the maximum value for lut entries, the number of values per lut 
+ * and the lut size in bytes.
+ */
+dc1394error_t dc1394_avt_get_lut_extd_info(dc1394camera_t *camera, 
+                                           uint32_t       *NumOfLuts, 
+                                           uint32_t       *MaxValue,
+                                           uint32_t       *NumOfValues,
+                                           uint32_t       *MaxLutSize);
+
+/**
+ * Get Autofunction AOI unit sizes. Only multiples of these units are allowed for 
+ * area position and size.
+ */
+dc1394error_t dc1394_avt_get_autofunc_aoi_info(dc1394camera_t *camera,
+                                               uint32_t       *unit_x, 
+                                               uint32_t       *unit_y);
+
+/**
+ * Get Autofunction AOI configuration (on/off and area).
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_get_autofunc_aoi
+ * instead.
  */
 dc1394error_t dc1394_avt_get_aoi(dc1394camera_t *camera,
                                  dc1394bool_t *on_off, int *left, int *top,
                                  int *width, int *height);
 
 /**
- * Set on/off and area
+ * Get Autofunction AOI configuration (on/off state, show area mode and area)
+ */
+dc1394error_t dc1394_avt_get_autofunc_aoi(dc1394camera_t *camera,
+                                          dc1394switch_t *on_off,
+                                          dc1394switch_t *show_area,
+                                          uint32_t       *left, 
+                                          uint32_t       *top,
+                                          uint32_t       *width,
+                                          uint32_t       *height);
+
+/**
+ * Set  Autofunction AOI configuration (on/off and area).
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_set_autofunc_aoi
+ * instead.
  */
 dc1394error_t dc1394_avt_set_aoi(dc1394camera_t *camera,
                                  dc1394bool_t on_off,int left, int top,
                                  int width, int height);
 
 /**
- * Get current test image
+ * Set Autofunction AOI configuration (on/off state, show area mode and area)
+ */
+dc1394error_t dc1394_avt_set_autofunc_aoi(dc1394camera_t *camera,
+                                          dc1394switch_t on_off,
+                                          dc1394switch_t show_area,
+                                          uint32_t       left, 
+                                          uint32_t       top,
+                                          uint32_t       width,
+                                          uint32_t       height);
+
+/**
+ * Get supported Test Images
+ */
+dc1394error_t dc1394_avt_get_test_images_info(dc1394camera_t *camera, 
+                                              dc1394bool_t   *TestImage1,
+                                              dc1394bool_t   *TestImage2,
+                                              dc1394bool_t   *TestImage3,
+                                              dc1394bool_t   *TestImage4,
+                                              dc1394bool_t   *TestImage5,
+                                              dc1394bool_t   *TestImage6,
+                                              dc1394bool_t   *TestImage7);
+
+/**
+ * Get Test Image configuration (Index 0 disables the feature)
  */
 dc1394error_t dc1394_avt_get_test_images(dc1394camera_t *camera,
                                          uint32_t *image_no);
 
 /**
- * Set num of test image
+ * Set Test Image configuration (Index 0 disables the feature)
  */
 dc1394error_t dc1394_avt_set_test_images(dc1394camera_t *camera,
                                          uint32_t image_no);
 
 /**
  * Get the number of captured frames
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_get_frame_counter 
+ * instead.
  */
 dc1394error_t dc1394_avt_get_frame_info(dc1394camera_t *camera,
                                         uint32_t *framecounter);
 
 /**
- * Reset frame counter
+ * Frame Counter: Get the number of captured frames
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry
+ */
+dc1394error_t dc1394_avt_get_frame_counter(dc1394camera_t                           *camera, 
+                                           const dc1394_avt_smart_feature_info_t    *feature_info, 
+                                           uint32_t                                 *framecounter);
+
+/**
+ * Reset Frame Counter
+ * This function is provided for backwards compatibility - new code should call dc1394_avt_reset_frame_counter 
+ * instead.
  */
 dc1394error_t dc1394_avt_reset_frame_info(dc1394camera_t *camera);
 
 /**
- * Get the size of the buffer
+ * Reset Frame Counter
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry
+ */
+dc1394error_t dc1394_avt_reset_frame_counter(dc1394camera_t                         *camera, 
+                                             const dc1394_avt_smart_feature_info_t  *feature_info);
+
+/**
+ * Trigger Counter: Get the number detected trigger events
+ */
+dc1394error_t dc1394_avt_get_trigger_counter(dc1394camera_t *camera, 
+                                             uint32_t       *triggercounter);
+
+/**
+ * Reset trigger counter
+ */
+dc1394error_t dc1394_avt_reset_trigger_counter(dc1394camera_t *camera);
+
+/**
+ * Get the size of the GP Data buffer
  */
 dc1394error_t dc1394_avt_get_gpdata_info(dc1394camera_t *camera,
                                          uint32_t *BufferSize);
@@ -403,7 +1066,7 @@
                                             dc1394bool_t SendImage );
 
 /**
- * Read size number of bytes from GPData buffe
+ * Read size number of bytes from GPData buffer
  */
 dc1394error_t dc1394_avt_read_gpdata(dc1394camera_t *camera, unsigned char *buf,
                                      uint32_t size);
@@ -415,28 +1078,46 @@
                                       unsigned char *buf, uint32_t size);
 
 /**
- * Read shading image from camera into buffer
+ * Read Shading Correction image from camera into buffer
  */
 dc1394error_t dc1394_avt_read_shading_img(dc1394camera_t *camera,
                                           unsigned char *buf, uint32_t size);
 
 /**
- * Write shading image from buffer to camera
+ * Write Shading Correction image from buffer to camera
  */
 dc1394error_t dc1394_avt_write_shading_img(dc1394camera_t *camera,
                                            unsigned char *buf, uint32_t size);
 
 /**
- * Read channel adjust (AVT Pike)
+ * Write LUT (look-up table) data from buffer to camera
+ */
+dc1394error_t dc1394_avt_write_lut(dc1394camera_t *camera, uint32_t LutNo, unsigned char *buf,
+                                   uint32_t size);
+
+/**
+ * Channel Balance: Read channel (gain) adjust (AVT Pike)
  */
 dc1394error_t dc1394_avt_get_channel_adjust(dc1394camera_t *camera,
-                                                int16_t *channel_adjust);
+                                            int16_t *channel_adjust);
 
 /**
- * Write channel adjust (AVT Pike)
+ * Channel Balance: Write channel (gain) adjust (AVT Pike)
  */
 dc1394error_t dc1394_avt_set_channel_adjust(dc1394camera_t *camera,
-                                                int16_t channel_adjust);
+                                            int16_t channel_adjust);
+
+/**
+ * Channel Balance: Read channel (offset) adjust (AVT Pike)
+ */
+dc1394error_t dc1394_avt_get_channel_adjust_offset(dc1394camera_t *camera,
+                                                   int16_t *channel_adjust);
+
+/**
+ * Channel Balance: Write channel (offset) adjust (AVT Pike)
+ */
+dc1394error_t dc1394_avt_set_channel_adjust_offset(dc1394camera_t *camera,
+                                                   int16_t channel_adjust);
 
 /**
  * Set Color Correction + Coefficients
@@ -451,15 +1132,218 @@
                 int32_t *Crr, int32_t *Cgr, int32_t *Cbr, int32_t *Crg, int32_t *Cgg, int32_t *Cbg, int32_t *Crb, int32_t *Cgb, int32_t *Cbb);
 
 /**
- * Get HSNR
+ * Get HSNR configuration
+ * ( on/off, num of frames used for averaging )
  */
 dc1394error_t dc1394_avt_get_hsnr(dc1394camera_t *camera, dc1394bool_t *on_off, uint32_t *grabCount);
 
 /**
- * Set HSNR
+ * Set HSNR configuration
+ * ( on/off, num of frames used for averaging )
  */
 dc1394error_t dc1394_avt_set_hsnr(dc1394camera_t *camera, dc1394bool_t on_off, uint32_t grabCount);
 
+
+/**
+ * Get SIS configuration
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry.
+ * Parameter userVal is only supported for newer camera families like Pike and Stingray and may be set to NULL.
+ */
+dc1394error_t dc1394_avt_get_sis(dc1394camera_t                         *camera, 
+                                 const dc1394_avt_smart_feature_info_t  *feature_info, 
+                                 dc1394switch_t                         *on_off, 
+                                 int16_t                                *linePos,
+                                 uint32_t                               *userVal);
+
+/**
+ * Set SIS configuration
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry.
+ * Changing linePos during image acquisition may lead to synchronization issues with dc1394_avt_get_sis_data.
+ */
+dc1394error_t dc1394_avt_set_sis(dc1394camera_t                         *camera, 
+                                 const dc1394_avt_smart_feature_info_t  *feature_info, 
+                                 dc1394switch_t                         on_off, 
+                                 int16_t                                linePos,
+                                 uint32_t                               userVal);
+
+/**
+ * Get supported SIS elements for a certain camera. Supported elements of sis_data_inquiry will be set to '1',
+ * '0' otherwise. Elements marked as 'reserved' are generally unsupported.
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry
+ */
+dc1394error_t dc1394_avt_get_sis_data_inquiry(const dc1394_avt_smart_feature_info_t *feature_info, 
+                                              dc1394_avt_sis_data                   *sis_data_inquiry );
+
+
+/**
+ * Retrieve SIS data from image data. 'linePos' needs to reflect the setting of the corresponding SIS parameter 
+ * at the time the image was aquired. Not all elements of sis_data are necessarily filled with valid data, depending 
+ * on the camera model. See dc1394_avt_get_sis_data_inquiry for supported elements.
+ * feature_info is needed to point to a properly filled info struct - see dc1394_avt_get_smart_feature_inquiry
+ */
+dc1394error_t dc1394_avt_get_sis_data(const dc1394_avt_smart_feature_info_t *feature_info,
+                                      dc1394video_frame_t                   *frame,
+                                      int16_t                               linePos,
+                                      dc1394_avt_sis_data                   *sis_data);
+
+/**
+ * Get 'Max Iso Size' settings. This feature overrides the maximum packet size for isochronuos
+ * transfers for a certain FireWire speed mode. The following speed modes are supported:
+ * 2: S400 setting
+ * 3: S800 setting
+ * 4: S1600 setting (future use)
+ * 5: S3200 setting (future use)
+ */
+dc1394error_t dc1394_avt_get_max_iso_size(dc1394camera_t *camera,
+                                          uint32_t       speed_mode,
+                                          dc1394switch_t *on_off,
+                                          uint32_t       *max_size);
+
+/**
+ * Set 'Max Iso Size' settings. This feature overrides the maximum packet size for isochronuos
+ * transfers for a certain FireWire speed mode. The following speed modes are supported:
+ * 2: S400 setting
+ * 3: S800 setting
+ * 4: S1600 setting (future use)
+ * 5: S3200 setting (future use)
+ * Parameter 'set_to_max' configures the maximum iso size possible.
+ *
+ * Caution: Activating this feature leads to bus utilization beyond FireWire Spec. Higher
+ * framerates can be achieved, but asynchronuos transfers may be delayed.
+ */
+dc1394error_t dc1394_avt_set_max_iso_size(dc1394camera_t *camera,
+                                          uint32_t       speed_mode,
+                                          dc1394switch_t on_off,
+                                          dc1394switch_t set_to_max,
+                                          uint32_t       max_size);
+
+/**
+ * Get Parameter Update Timing. The following modes are supported:
+ * 0: Standard Parameter Update Timing
+ * 2: Quick Format Change Mode - A running image integration will be stopped when
+ * new settings have to be applied
+ */
+dc1394error_t dc1394_avt_get_param_upd_timing(dc1394camera_t *camera,
+                                              uint32_t       *update_timing_mode);
+
+/**
+ * Set Parameter Update Timing. The following modes are supported:
+ * 0: Standard Parameter Update Timing
+ * 2: Quick Format Change Mode - A running image integration will be stopped when
+ * new settings have to be applied
+ */
+dc1394error_t dc1394_avt_set_param_upd_timing(dc1394camera_t *camera,
+                                              uint32_t       update_timing_mode);
+
+/**
+ * Get Low Smear configuration
+ */
+dc1394error_t dc1394_avt_get_low_smear(dc1394camera_t *camera,
+                                       dc1394switch_t *on_off);
+
+/**
+ * Set Low Smear configuration
+ */
+dc1394error_t dc1394_avt_set_low_smear(dc1394camera_t *camera,
+                                       dc1394switch_t on_off);
+
+/**
+ * Get Low Noise Binning 
+ */
+dc1394error_t dc1394_avt_get_low_noise_binning(dc1394camera_t *camera,
+                                               dc1394switch_t *on_off);
+
+/**
+ * Set Low Noise Binning 
+ */
+dc1394error_t dc1394_avt_set_low_noise_binning(dc1394camera_t *camera,
+                                               dc1394switch_t on_off);
+
+/**
+ * Get Global Reset Release Shutter 
+ */
+dc1394error_t dc1394_avt_get_global_res_rel_shutter(dc1394camera_t *camera,
+                                                    dc1394switch_t *on_off);
+
+/**
+ * Set Global Reset Release Shutter 
+ */
+dc1394error_t dc1394_avt_set_global_res_rel_shutter(dc1394camera_t *camera,
+                                                    dc1394switch_t on_off);
+
+/**
+ * Get User Profile settings. This feature is an AVT-specific extension of the standard IIDC memory feature.
+ */
+dc1394error_t dc1394_avt_get_user_profile(dc1394camera_t *camera,
+                                          uint32_t       *profile_id,
+                                          dc1394bool_t   *error,
+                                          uint32_t       *err_code );
+
+/**
+ * Set User Profile settings. This feature is an AVT-specific extension of the standard IIDC memory feature.
+ * The number of supported user profiles is indicated by the max_mem_channel member of dc1394camera_t.
+ */
+dc1394error_t dc1394_avt_set_user_profile(dc1394camera_t *camera,
+                                          uint32_t       profile_id,
+                                          dc1394switch_t load_profile,
+                                          dc1394switch_t save_profile,
+                                          dc1394switch_t set_default);
+
+/**
+ * Get LED configuration - controls 'SW Feature - LED' functionality to blank the camera's status LEDs 
+ */
+dc1394error_t dc1394_avt_get_led(dc1394camera_t *camera,
+                                 dc1394switch_t *on_off);
+
+/**
+ * Set LED configuration - controls 'SW Feature - LED' functionality to blank the camera's status LEDs 
+ */
+dc1394error_t dc1394_avt_set_led(dc1394camera_t *camera,
+                                 dc1394switch_t on_off);
+
+/**
+ * Get info for feature Defect Pixel Correction: valid range for threshold, maximum size of defect pixel data
+ */
+dc1394error_t dc1394_avt_get_dpc_info(dc1394camera_t *camera,
+                                      uint32_t       *MinThreshold,
+                                      uint32_t       *MaxThreshold,
+                                      uint32_t       *MaxSize);
+
+/**
+ * Get configuration for Defect Pixel Correction: on/off, threshold for computation, mean value and size of computed data
+ */
+dc1394error_t dc1394_avt_get_dpc(dc1394camera_t *camera,
+                                 dc1394switch_t *on_off,
+                                 uint32_t       *threshold,
+                                 uint32_t       *mean_value,
+                                 uint32_t       *data_size);
+
+/**
+ * Set configuration for Defect Pixel Correction: on/off, threshold for computation, mean value and size of computed data
+ */
+dc1394error_t dc1394_avt_set_dpc(dc1394camera_t *camera,
+                                 dc1394switch_t on_off,
+                                 dc1394switch_t build_data,
+                                 dc1394switch_t zero_data,
+                                 dc1394switch_t mem_save,
+                                 dc1394switch_t mem_load,
+                                 uint32_t       threshold);
+
+/**
+ * Download Defect Pixel Correction data to PC. PixelCount will return the number of pixels that have been read.
+ * BufferSize indicates the size of DestBuffer in Pixels
+ */
+dc1394error_t dc1394_avt_read_dpc_data(dc1394camera_t                *camera,
+                                       dc1394_avt_dpc_pixel_position *DestBuffer,
+                                       uint32_t                      *PixelCount,
+                                       uint32_t                      BufferSize );
+
+/**
+ * Upload Defect Pixel Correction data to camera. PixelCount indicates the number of pixels to be written.
+ */
+dc1394error_t dc1394_avt_write_dpc_data(dc1394camera_t                *camera,
+                                        dc1394_avt_dpc_pixel_position *SourceBuffer,
+                                        uint32_t                      PixelCount);
 #ifdef __cplusplus
 }
 #endif
diff -Nur libdc1394-2.1.2/examples/avt_singleview.1 libdc1394_avt-2.1.2/examples/avt_singleview.1
--- libdc1394-2.1.2/examples/avt_singleview.1	1970-01-01 01:00:00.000000000 +0100
+++ libdc1394_avt-2.1.2/examples/avt_singleview.1	2010-01-14 18:43:14.000000000 +0100
@@ -0,0 +1,24 @@
+.TH DC1394_SINGLEVIEW "1" "January 2010" "avt_singleview " "User Commands"
+.SH NAME
+dc1394_singleview \- display format0 camera video
+.SH SYNOPSIS
+.B avt_singleview [colorcode]
+.SH DESCRIPTION
+View format0-only camera video from one camera.
+.SH OPTIONS
+.TP
+\fBcolorcode\fR
+Color code used for camera configuration. Default is mono8. Supported color codes are mono8, yuv411, yuv422, yuv444, rgb8, mono16, raw8, raw16, avt_mono12, avt_raw12.
+.PP
+.SH KEYBOARD CONTROLS
+.TP
+\fBq\fR
+quit
+.TP
+\fBw\fR 
+adjust white balance
+.TP
+\fB0\fR
+pause
+
+
diff -Nur libdc1394-2.1.2/examples/avt_singleview.c libdc1394_avt-2.1.2/examples/avt_singleview.c
--- libdc1394-2.1.2/examples/avt_singleview.c	1970-01-01 01:00:00.000000000 +0100
+++ libdc1394_avt-2.1.2/examples/avt_singleview.c	2010-05-19 12:16:55.000000000 +0200
@@ -0,0 +1,419 @@
+/*
+ * 1394-Based Digital Camera Control Library
+ *
+ * Written by Damien Douxchamps <ddouxchamps@users.sf.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <signal.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/Xvlib.h>
+#include <X11/keysym.h>
+#define _GNU_SOURCE
+#include <getopt.h>
+#include <stdint.h>
+#include <inttypes.h>
+
+#include "dc1394/dc1394.h"
+#include "dc1394/vendor/avt.h"
+
+/* uncomment the following to drop frames to prevent delays */
+#define NUM_BUFFERS 8
+
+/* ok the following constant should be by right included thru in Xvlib.h */
+#ifndef XV_YV12
+#define XV_YV12 0x32315659
+#endif
+
+#ifndef XV_YUY2
+#define XV_YUY2 0x32595559
+#endif
+
+#ifndef XV_UYVY
+#define XV_UYVY 0x59565955
+#endif
+
+
+/* declarations for libdc1394 */
+dc1394camera_t *camera;
+dc1394featureset_t features;
+dc1394video_frame_t * frame_received;
+dc1394video_frame_t frame_raw8;
+dc1394video_frame_t frame_debayered;
+dc1394video_frame_t frame_yuv422;
+
+/* declarations for video1394 */
+unsigned long device_width,device_height, 
+              device_left,device_top; 
+
+
+/* declarations for Xwindows */
+Display *display=NULL;
+Window window=(Window)NULL;
+unsigned long width,height;
+int connection=-1;
+XvImage *xv_image=NULL;
+XvAdaptorInfo *info;
+GC gc;
+
+/* Other declarations */
+unsigned long frame_length;
+int adaptor=-1;
+
+int freeze=0;
+int color_coding;
+uint32_t Camera_ID;
+
+uint32_t hsize, vsize, hstep, vstep;
+
+
+/* helper functions */
+void display_frame()
+{
+    if(!freeze && adaptor>=0){
+        if (!frame_received)
+            return;
+
+        dc1394_avt_adjust_frames(Camera_ID, frame_received);
+
+        switch (frame_received->color_coding) {
+            /* color codes that can be converted to YUV422 by dc1394_convert_frames */
+            case DC1394_COLOR_CODING_YUV411:
+            case DC1394_COLOR_CODING_YUV422:
+            case DC1394_COLOR_CODING_YUV444:
+            case DC1394_COLOR_CODING_RGB8:
+            case DC1394_COLOR_CODING_MONO8:
+            case DC1394_COLOR_CODING_MONO16:
+            case DC1394_COLOR_CODING_AVT_MONO12:
+                dc1394_convert_frames(frame_received, &frame_yuv422);
+                break;
+ 
+            /* color codes that need to be debayered to rgb8/16 first */
+            case DC1394_COLOR_CODING_RAW8:
+                frame_debayered.color_coding = DC1394_COLOR_CODING_RGB8;
+                dc1394_debayer_frames(frame_received, &frame_debayered, DC1394_BAYER_METHOD_SIMPLE);
+                dc1394_convert_frames(&frame_debayered, &frame_yuv422);
+                break;
+
+            case DC1394_COLOR_CODING_RAW16:
+                frame_debayered.color_coding = DC1394_COLOR_CODING_RGB16;
+                dc1394_debayer_frames(frame_received, &frame_debayered, DC1394_BAYER_METHOD_SIMPLE);
+                dc1394_convert_frames(&frame_debayered, &frame_yuv422);
+                break;
+
+            /* raw12 needs to be converted to raw8/raw16 first 
+               (call dc1394_convert_packed12_to_16 to retrieve raw16 instead of raw8) */
+            case DC1394_COLOR_CODING_AVT_RAW12:
+                dc1394_convert_frames(frame_received, &frame_raw8);
+                frame_debayered.color_coding = DC1394_COLOR_CODING_RGB8;
+                dc1394_debayer_frames(&frame_raw8, &frame_debayered, DC1394_BAYER_METHOD_SIMPLE);
+                dc1394_convert_frames(&frame_debayered, &frame_yuv422);
+                break;
+
+            default:
+                break;
+        }
+
+        xv_image=XvCreateImage(display,info[adaptor].base_id,XV_YUY2,(char*)frame_yuv422.image,
+                            device_width,device_height);
+        XvPutImage(display,info[adaptor].base_id,window,gc,xv_image,
+                0,0,device_width,device_height,
+                0,0,width,height);
+        xv_image=NULL;
+    }
+}
+
+
+void QueryXv()
+{
+    uint32_t num_adaptors;
+    int num_formats;
+    XvImageFormatValues *formats=NULL;
+    int i,j;
+    char xv_name[5];
+
+    XvQueryAdaptors(display,DefaultRootWindow(display),&num_adaptors,&info);
+
+    for(i=0;i<num_adaptors;i++) {
+        formats=XvListImageFormats(display,info[i].base_id,&num_formats);
+        for(j=0;j<num_formats;j++) {
+            xv_name[4]=0;
+            memcpy(xv_name,&formats[j].id,4);
+            if(formats[j].id==XV_YUY2) {
+                dc1394_log_error("using Xv format 0x%x %s %s",formats[j].id,xv_name,(formats[j].format==XvPacked)?"packed":"planar");
+                if(adaptor<0) adaptor=i;
+            }
+        }
+    }
+    XFree(formats);
+    if(adaptor<0)
+        dc1394_log_error("No suitable Xv adaptor found");
+}
+
+
+void cleanup(void) {
+    dc1394_video_set_transmission(camera, DC1394_OFF);
+    dc1394_capture_stop(camera);
+
+    if ((void *)window != NULL)
+        XUnmapWindow(display,window);
+    if (display != NULL)
+        XFlush(display);
+
+    if(frame_raw8.image) {
+        free(frame_raw8.image);
+        frame_raw8.image = NULL;
+    }
+    if(frame_debayered.image) {
+        free(frame_debayered.image);
+        frame_debayered.image = NULL;
+    }
+    if(frame_yuv422.image) {
+        free(frame_yuv422.image);
+        frame_yuv422.image = NULL;
+    }
+}
+
+
+/* trap ctrl-c */
+void signal_handler( int sig) {
+    signal( SIGINT, SIG_IGN);
+    cleanup();
+    exit(0);
+}
+
+
+int main(int argc,char *argv[])
+{
+    XEvent xev;
+    XGCValues xgcv;
+    long background=0x010203;
+    dc1394_t * d;
+    dc1394camera_list_t * list;
+    dc1394error_t err;
+    uint32_t dummy1, dummy2, dummy3;
+    dc1394color_codings_t supported_color_codings;
+    int i;
+
+    /* check parameters */
+    switch( argc ) {
+        case 1:
+            printf("No color coding specified, mono8 is used as default\n");
+            color_coding=DC1394_COLOR_CODING_MONO8;
+            break;
+        case 2:
+            if(0==strcmp( argv[1], "-h" ) ||
+               0==strcmp( argv[1], "--help" ) ||
+               0==strcmp( argv[1], "-?" )) {
+                printf(" usage: avt_singleview color_code\n    supported color codes:\n      mono8\n      yuv411\n      yuv422\n      yuv444\n"
+                       "      rgb8\n      mono16\n      raw8\n      raw16\n      avt_mono12\n      avt_raw12\n");
+                exit(0); 
+            }
+            else if(0==strcmp( argv[1], "mono8" ))
+                color_coding=DC1394_COLOR_CODING_MONO8;
+            else if(0==strcmp( argv[1], "yuv411" ))
+                color_coding=DC1394_COLOR_CODING_YUV411;
+            else if(0==strcmp( argv[1], "yuv422" ))
+                color_coding=DC1394_COLOR_CODING_YUV422;
+            else if(0==strcmp( argv[1], "yuv444" ))
+                color_coding=DC1394_COLOR_CODING_YUV444;
+            else if(0==strcmp( argv[1], "rgb8" ))
+                color_coding=DC1394_COLOR_CODING_RGB8;
+            else if(0==strcmp( argv[1], "mono16" ))
+                color_coding=DC1394_COLOR_CODING_MONO16;
+            else if(0==strcmp( argv[1], "raw8" ))
+                color_coding=DC1394_COLOR_CODING_RAW8;
+            else if(0==strcmp( argv[1], "raw16" ))
+                color_coding=DC1394_COLOR_CODING_RAW16;
+            else if(0==strcmp( argv[1], "avt_mono12" ))
+                color_coding=DC1394_COLOR_CODING_AVT_MONO12;
+            else if(0==strcmp( argv[1], "avt_raw12" ))
+                color_coding=DC1394_COLOR_CODING_AVT_RAW12;
+            else {
+                printf(" unknown color code, \n \"avt_singleview -?\" for help\n");
+                exit(0); 
+            }
+            break;
+        default:
+            printf(" too many parameters, \n \"avt_singleview -?\" for help\n");
+            exit(0);
+    }
+
+    /* init frame structs */
+    frame_received = NULL;
+    memset( &frame_debayered, 0, sizeof(dc1394video_frame_t) );
+    memset( &frame_yuv422, 0, sizeof(dc1394video_frame_t) );
+    memset( &frame_raw8, 0, sizeof(dc1394video_frame_t) );
+    frame_yuv422.color_coding = DC1394_COLOR_CODING_YUV422;
+    frame_yuv422.yuv_byte_order = DC1394_BYTE_ORDER_YUYV;
+    frame_raw8.color_coding = DC1394_COLOR_CODING_RAW8;
+
+    /* init libdc, open first camera */
+    d = dc1394_new ();
+    if (!d)
+        return 1;
+    err=dc1394_camera_enumerate (d, &list);
+    DC1394_ERR_RTN(err,"Failed to enumerate cameras");
+
+    if (list->num == 0) {
+        dc1394_log_error("No cameras found");
+        return 1;
+    }
+
+    camera = dc1394_camera_new (d, list->ids[0].guid);
+    if (!camera) 
+        dc1394_log_warning("Failed to initialize camera with guid %llx", list->ids[0].guid);
+    dc1394_camera_free_list (list);
+
+    srand(time(NULL));
+
+    /* get camera information (we need to know Camera_ID for dc1394_avt_adjust_frames) */
+    dc1394_avt_get_version(camera, &dummy1, &dummy2, &Camera_ID, &dummy3);
+
+    /* init camera */
+    err=dc1394_video_set_iso_speed(camera, DC1394_ISO_SPEED_400);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not set ISO speed");
+
+    err=dc1394_format7_get_max_image_size(camera, DC1394_VIDEO_MODE_FORMAT7_0, &hsize, &vsize);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not get max image size");
+
+    err=dc1394_format7_get_unit_size(camera, DC1394_VIDEO_MODE_FORMAT7_0, &hstep, &vstep);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not get unit size");
+
+    err=dc1394_format7_get_color_codings(camera, DC1394_VIDEO_MODE_FORMAT7_0, &supported_color_codings);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not get supported color codings");
+
+    for( i=0; i<supported_color_codings.num; i++ ) {
+        if( supported_color_codings.codings[i] == color_coding )
+            break;
+        if( i==supported_color_codings.num-1 ) {
+            dc1394_log_error("Color Coding not supported by camera");
+	    exit(-1);
+        }
+    }
+
+    /* setup camera for capture */    
+    device_width  = hsize;
+    device_height = vsize;
+    device_left   = 0;
+    device_top    = 0;
+
+    printf("Trying to setup mode %ldx%ld+%ld+%ld\n", 
+        device_width, device_height, device_left, device_top );
+
+    err=dc1394_format7_set_roi(camera, DC1394_VIDEO_MODE_FORMAT7_0, color_coding,
+                               DC1394_USE_MAX_AVAIL, 
+                               device_left, device_top, device_width, device_height);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not setup camera-\nmake sure that the video mode and framerate are\nsupported by your camera");
+
+    err=dc1394_video_set_mode(camera, DC1394_VIDEO_MODE_FORMAT7_0);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not set camera mode");
+
+    err= dc1394_capture_setup(camera,NUM_BUFFERS, DC1394_CAPTURE_FLAGS_DEFAULT);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Final capture setup failed!");
+
+    err=dc1394_video_set_transmission(camera, DC1394_ON);
+    DC1394_ERR_CLN_RTN(err,cleanup(),"Could not start camera iso transmission");
+
+
+    /* make the window */
+    display=XOpenDisplay(getenv("DISPLAY"));
+    if(display==NULL) {
+        dc1394_log_error("Could not open display \"%s\"",getenv("DISPLAY"));
+        cleanup();
+        exit(-1);
+    }
+
+    QueryXv();
+
+    if ( adaptor < 0 ) {
+        cleanup();
+        exit(-1);
+    }
+
+    if (dc1394_capture_dequeue(camera, DC1394_CAPTURE_POLICY_POLL, &frame_received)!=DC1394_SUCCESS)
+    dc1394_log_error("Failed to capture from camera");
+
+
+    display_frame();
+
+    width=device_width;
+    height=device_height;
+
+    window=XCreateSimpleWindow(display,DefaultRootWindow(display),0,0,width,height,0,
+                               WhitePixel(display,DefaultScreen(display)),
+                               background);
+
+    XSelectInput(display,window,StructureNotifyMask|KeyPressMask);
+    XMapWindow(display,window);
+    connection=ConnectionNumber(display);
+
+    gc=XCreateGC(display,window,0,&xgcv);
+
+    /* main event loop */
+    while(1){
+        if (dc1394_capture_dequeue(camera, DC1394_CAPTURE_POLICY_WAIT, &frame_received)!=DC1394_SUCCESS)
+                dc1394_log_error("Failed to capture from camera");
+
+        display_frame();
+        XFlush(display);
+
+        while(XPending(display)>0){
+            XNextEvent(display,&xev);
+            switch(xev.type){
+            case ConfigureNotify:
+                width=xev.xconfigure.width;
+                height=xev.xconfigure.height;
+                display_frame();
+                break;
+            case KeyPress:
+                switch(XKeycodeToKeysym(display,xev.xkey.keycode,0)){
+                case XK_q:
+                case XK_Q:
+                    cleanup();
+                    exit(0);
+                    break;
+                case XK_0:
+                    freeze = !freeze;
+                    break;
+                case XK_w:
+                case XK_W:
+                    dc1394_feature_set_mode(camera, DC1394_FEATURE_WHITE_BALANCE,  DC1394_FEATURE_MODE_ONE_PUSH_AUTO);
+                    DC1394_ERR_CLN_RTN(err,cleanup(),"Count not one-push WB");
+                    break;
+                default:
+                    break;
+                }
+                break;
+            }
+        } /* XPending */
+
+        if (frame_received && frame_received->image)
+            dc1394_capture_enqueue (camera, frame_received);
+
+    } /* while not interrupted */
+
+    exit(0);
+}
--- libdc1394-2.2.7/examples/Makefile.am.orig	2023-06-26 20:45:22.699234310 +0200
+++ libdc1394-2.2.7/examples/Makefile.am	2023-06-26 20:50:47.940805659 +0200
@@ -1,5 +1,5 @@
 MAINTAINERCLEANFILES = Makefile.in
-dist_man_MANS = dc1394_multiview.1  dc1394_reset_bus.1  dc1394_vloopback.1  grab_color_image.1  grab_gray_image.1  grab_partial_image.1
+dist_man_MANS = dc1394_multiview.1  dc1394_reset_bus.1  dc1394_vloopback.1  grab_color_image.1  grab_gray_image.1  grab_partial_image.1  avt_singleview.1
 AM_CPPFLAGS = -I$(top_srcdir)
 
 A = grab_gray_image grab_partial_image grab_color_image \
@@ -18,7 +18,7 @@ if HAVE_VIDEODEV
 B += dc1394_vloopback
 endif
 if HAVE_XV
-A += dc1394_multiview
+A += dc1394_multiview avt_singleview
 endif
 if HAVE_OPENGL
 GL_LIBS = -lGL
@@ -62,6 +62,10 @@ dc1394_vloopback_LDADD = $(LDADD) -lm
 
 dc1394_reset_bus_SOURCES = dc1394_reset_bus.c
 
+avt_singleview_CFLAGS = $(X_CFLAGS) $(XV_CFLAGS)
+avt_singleview_SOURCES = avt_singleview.c
+avt_singleview_LDADD = $(LDADD) $(X_LIBS) $(X_PRE_LIBS) $(XV_LIBS) -lX11 $(X_EXTRA_LIBS)
+
 basler_sff_info_SOURCES = basler_sff_info.c
 
 basler_sff_extended_data_SOURCES = basler_sff_extended_data.c
diff -Nur libdc1394-2.1.2/README libdc1394_avt-2.1.2/README
--- libdc1394-2.1.2/README	2009-06-11 06:05:47.000000000 +0200
+++ libdc1394_avt-2.1.2/README	2010-03-26 13:46:57.000000000 +0100
@@ -17,6 +17,30 @@
 David Moore in 2006. A Windows version is in the works.
 
 
+This readme file is distributed with the libdc1394_avt, which is a fork of the
+original libdc1394. Beside the features of the libdc1394 library, this release 
+contains extensions for vendor-specific features and color formats supported by 
+AVT cameras.
+
+Most information given in this file do originally refer to the mainstream 
+libdc1394 release.
+
+The libdc1394_avt fork is part of the AVT Fire4Linux 3.0 package distributed by:
+
+Allied Vision Technologies GmbH
+Taschenweg 2a
+07646 Stadtroda
+Germany
+www.alliedvisiontec.com
+
+For questions and feedback referring to the AVT-specific extensions contact one
+of the following addresses:
+- info@alliedvisiontec.com     for general information
+- support@alliedvisiontec.com  for support requests
+- f4l@alliedvisiontec.com      for development-related feedback
+
+
+
 2. Copyleft
 
 The 1394-Based Digital Camera Control Library is licensed under the Lesser
@@ -74,3 +98,6 @@
 --
 2000-01-13  Gord Peters
 2008-01-05  Damien Douxchamps
+
+
+2010-03-26 Additional Code by Allied Vision Technologies
